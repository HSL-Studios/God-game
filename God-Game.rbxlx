<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX922EF9E643CC4D59A72F81FFADD69437">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="CollisionGroups">Default^0^1</string>
			<Ref name="CurrentCamera">RBX6205CB1A7580488ABCBEF0C314163EB0</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<bool name="FilteringEnabled">true</bool>
			<float name="Gravity">196.199997</float>
			<token name="LevelOfDetail">0</token>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
		</Properties>
		<Item class="Camera" referent="RBX6205CB1A7580488ABCBEF0C314163EB0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>9.31504474e-09</X>
					<Y>15.6884584</Y>
					<Z>15.6317148</Z>
					<R00>1</R00>
					<R01>-8.8760423e-08</R01>
					<R02>2.43075277e-07</R02>
					<R10>-7.1054282e-15</R10>
					<R11>0.939334095</R11>
					<R12>0.343003571</R12>
					<R20>-2.58774065e-07</R20>
					<R21>-0.343003571</R21>
					<R22>0.939334095</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-4.76837158e-07</X>
					<Y>15.002449</Y>
					<Z>13.7530403</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXFA87C4345D95497DB28CDCD66C32AFD4">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284702562</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Baseplate</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">0</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>512</X>
					<Y>20</Y>
					<Z>512</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX3959BFBDF2DB40968B4A877750D14166">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0470588282</R>
					<G>0.329411775</G>
					<B>0.360784322</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXC9E35718E8304D82921930EF0D83D562">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>4</X>
					<Y>0.5</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="Weld" referent="RBXB587B1AE90CF4454AB1E65F7B3308A05">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<CoordinateFrame name="C0">
						<X>-256</X>
						<Y>10</Y>
						<Z>256</Z>
						<R00>-1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>1</R12>
						<R20>0</R20>
						<R21>1</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<CoordinateFrame name="C1">
						<X>-260</X>
						<Y>-0.5</Y>
						<Z>261</Z>
						<R00>-1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>1</R12>
						<R20>0</R20>
						<R21>1</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="Enabled">true</bool>
					<string name="Name">Weld</string>
					<Ref name="Part0">RBXFA87C4345D95497DB28CDCD66C32AFD4</Ref>
					<Ref name="Part1">RBXC9E35718E8304D82921930EF0D83D562</Ref>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX4443C39570834DF693E722E3C3F44D37">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>1.50001204</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX6901E4DFBB71437A8F30B31A07293386">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>-5</X>
					<Y>2.5</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX569E37CF6DF6412798EF5D390812E88A">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>3.50003505</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX649DFF90643044BD8BC98A901EDAC2F3">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>5</X>
					<Y>4.5</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXED1954BF594440C8BAFE69C96D4BA9D3">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>5.50005817</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX2C510F2E72644F1DA0D2B0E0501C6401">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>-5</X>
					<Y>6.5000701</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">Part</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBX64E5C512F18C4C54BBA2DEBE9F04678C">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX758313CDDCEA48519686277D21CF75E9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXC16D664048E6484C894528280CC1EE87">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXC4A6282B6B894CFE9A22F36C9B94AC4F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBXD6DC81199499440C8BB0D55A870271F0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX256C6E64776E435FBBEEC3C8EBF9E3AD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">30</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">30</int>
			<float name="RespawnTime">5</float>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX767328369ADB4D91A769EDBC44AD608E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX7F843CCC798B4E2DBE4367F78F87519F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Aero</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="LocalScript" referent="RBX72EC92B2A83A4928B0C303A7A6998945">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AeroLoad</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	
	At its heart, the way to wait for the AeroGameFramework to
	load is to simply wait for it to exist in the _G table:
	
		while (not _G.Aero) do wait() end
		local aero = _G.Aero
	
	
	The following code shows how to do this with a custom GUI,
	but you will have to fill in some of the code yourself.

	IF YOU USE THIS CODE, MAKE SURE TO PUT IT IN A FILE NAMED 
	SOMETHING OTHER THAN 'AeroLoad' SO FUTURE FRAMEWORK UPDATES 
	DO NOT OVERWRITE YOUR CUSTOM 'AeroLoad' SCRIPT. YOU CAN NAME 
	IT ANYTHING, LIKE 'MyCustomAeroLoad'
	
]]

--[[  UNCOMMENT TO USE THIS TEMPLATE (BUT BE SURE TO ADD YOUR OWN GUI ON LINE 47)

local player = game.Players.LocalPlayer

-- Temporary blackout used until the Aero Fade module is loaded:
local tempBlackout = Instance.new("ScreenGui")
tempBlackout.Name = "TemporaryBlackout"
tempBlackout.DisplayOrder = 10
do
	local frame = Instance.new("Frame")
	frame.Name = "Overlay"
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Size = UDim2.new(2, 0, 2, 0)
	frame.BackgroundColor3 = Color3.new(0, 0, 0)
	frame.Parent = tempBlackout
end

-- Remove default loading screen & replace with a temporary black overlay:
tempBlackout.Parent = player:WaitForChild("PlayerGui")
game:GetService("ReplicatedFirst"):RemoveDefaultLoadingScreen()

-- Wait for the Aero client to load:
while (not _G.Aero) do wait() end
local aero = _G.Aero

-- Make screen black using the Aero Fade module:
aero.Controllers.Fade:Out(0)

-- Remove the temporary overlay, since we don't need it anymore:
tempBlackout:Destroy()

-- Add in your own loading screen GUI:
local loadingGui = script.YOUR_CUSTOM_GUI
loadingGui.Parent = player:WaitForChild("PlayerGui")

-- Fade in slowly to show your loading screen:
aero.Controllers.Fade:In(1)

-- Wait for the game to load if not loaded yet:
if (not game:IsLoaded()) then
	game.Loaded:Wait()
end

-- INSERT OTHER LOADING THINGS HERE
-- EXAMPLE: game:GetService("ContentProvider"):PreloadAsync({foo, bar, etc})

-- Fade out to black, remove your GUI, and then fade back in:
wait(3)
aero.Controllers.Fade:Out(1)
loadingGui:Destroy()
aero.Controllers.Fade:In(1)

]]
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="TweenService" referent="RBXB92947FC502B43E499B3555212DC8949">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PermissionsService" referent="RBX46CAD6EF5F82422EB5D7D4B4EA47862A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXED50442DAA944FDEBCA406358F829608">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<bool name="EnableScriptCollabOnLoad">false</bool>
			<bool name="EnableScriptCollabVersionHistoryOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SrcPlaceId">5385230882</int64>
			<int64 name="SrcUniverseId">1886514234</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBXE29F82263D524CFB9A3F67FBD7525D18">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">128</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBX900AACD8DD6A4F57A6142F9879D9AB3F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX7E532601215F4A07BFC0CF34633D83DB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Aero</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXBA39DD6506EE433DB7FAABD8640A66F7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Controllers</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC5F7810DD2BE47958A266963214189B9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Fade</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- Fade
-- Stephen Leitnick
-- February 4, 2017

--[[
	
	
	METHODS:
	
		Fade:In([duration [, async] ])                  Fade in from black
		Fade:Out([duration [, async] ])                 Fade out to black
		
		Fade:To(transparency [, duration [, async] ])   Fade to the given transparency level
		Fade:FromTo(from, to [, duration [, async] ])   Fade from one transparency level to another
		
		Fade:SetText(text)                              Set text to show on fade screen
		Fade:ClearText()                                Sets text to a blank string
		Fade:SetTextSize(size)				Sets the text size (0 for auto scaling)
		Fade:SetFont(font)                              Sets the font
		
		Fade:SetBackgroundColor(color)                  Set the fade color (can be a Color3 or BrickColor)
		Fade:SetTextColor(color)                        Set the text color (can be a Color3 or BrickColor)
		
		Fade:SetEasingStyle(easingStyle)                Set the easing style (e.g. Enum.EasingStyle.Quad)
		
		Fade:GetScreenGui()                             Returns the ScreenGui for this fade system
		Fade:GetFrame()                                 Returns the overlay Frame
		Fade:GetLabel()                                 Returns the TextLabel used for showing text
	
	
	EVENTS:
		
		Fade.Started()
		Fade.Ended()
	
	
	
	EXAMPLES:
		
		-- Hello fade:
		Fade:SetText("Hello")
		Fade:Out()
		wait(1)
		Fade:In()
		
		-- Slow fade:
		Fade:ClearText()
		Fade:Out(5)
		wait(1)
		Fade:In(5)
		
		-- Half fade:
		Fade:To(0.5)
		
		-- Asynchronous w/ events:
		Fade.Ended:connect(function()
			print("Fade ended!")
		end)
		Fade:Out(1, true)
	
	
	
	
	Note: This module is dependent on the Tween module.
	
--]]



local Fade = {}


local DEFAULT_DURATION = 0.5
local DEFAULT_ASYNC    = false


-- ScreenGui:
local fadeGui = Instance.new("ScreenGui")
	fadeGui.Name = "FadeGui"
	fadeGui.DisplayOrder = 9
	fadeGui.ResetOnSpawn = false
	fadeGui.IgnoreGuiInset = true -- Now ignores the inset because what kind of monster would want this off?

-- Main overlay frame:
local fade = Instance.new("Frame")
	fade.Name = "Fade"
	fade.Size = UDim2.new(1, 0, 1, 0)
	fade.Position = UDim2.new(0, 0, 0, 0)
	fade.BorderSizePixel = 0
	fade.BackgroundColor3 = Color3.new(0, 0, 0)
	fade.BackgroundTransparency = 1
	fade.Parent = fadeGui

-- Text label:
local label = Instance.new("TextLabel")
	label.Name = "Label"
	label.AnchorPoint = Vector2.new(0.5, 0.5)
	label.BackgroundTransparency = 1
	label.Font = Enum.Font.SourceSans
	label.TextScaled = true
	label.TextWrapped = true
	label.Size = UDim2.new(1, 0, 1, 0)
	label.Position = UDim2.new(0.5, 0, 0.5, 0)
	label.TextColor3 = Color3.new(1, 1, 1)
	label.Text = ""
	label.Parent = fade


local easingStyle = Enum.EasingStyle.Quad

local Tween
local currentTween

--local fadeStarted
--local fadeEnded

local fadeStartedEvent = "Started"
local fadeEndedEvent = "Ended"


-- Set background color:
function Fade:SetBackgroundColor(c)
	local t = typeof(c)
	if (t == "Color3") then
		fade.BackgroundColor3 = c
	elseif (t == "BrickColor") then
		fade.BackgroundColor3 = c.Color
	else
		error("Argument must be of type Color3 or BrickColor")
	end
end


-- Set text color:
function Fade:SetTextColor(c)
	local t = typeof(c)
	if (t == "Color3") then
		label.TextColor3 = c
	elseif (t == "BrickColor") then
		label.TextColor3 = c.Color
	else
		error("Argument must be of type Color3 or BrickColor")
	end
end


-- Set text:
function Fade:SetText(text)
	label.Text = (text == nil and "" or tostring(text))
end


-- Set text size:
function Fade:SetTextSize(size)
	-- Turn off text wrapping no matter what because if we turn on text scaling, wrapping will automatically turn back on
	label.TextWrapped = false
	label.TextScaled = (size == 0 and true or false)
	label.TextSize = (size == 0 and label.TextSize or size) -- Don't bother changing text size if we turn on auto scaling
end


-- Set font:
function Fade:SetFont(font)
	label.Font = font
end


-- Clear text:
function Fade:ClearText()
	self:SetText(nil)
end


-- Fade in (fade the transparency frame out of the picture)
function Fade:In(duration, async)
	self:FromTo(0, 1, duration, async)
end


--  Fade out (fade the transparency frame into picture)
function Fade:Out(duration, async)
	self:FromTo(1, 0, duration, async)
end


-- Fade to a transparency, starting at whatever transparency level it is currently:
function Fade:To(transparency, duration, async)
	self:FromTo(fade.BackgroundTransparency, transparency, duration, async)
end


-- Fade from a transparency to another:
function Fade:FromTo(fromTransparency, toTransparency, duration, async)
	
	assert(type(fromTransparency) == "number", "'fromTransparency' argument must be a number")
	assert(type(toTransparency) == "number", "'toTransparency' argument must be a number")
	assert(duration == nil or type(duration) == "number", "'duration' argument must be a number or nil")
	
	duration = (duration or DEFAULT_DURATION)
	
	if (duration <= 0) then
		-- Instant fade; skip everything else:
		self:FireEvent(fadeStartedEvent)
		fade.BackgroundTransparency = toTransparency
		label.TextTransparency = toTransparency
		self:FireEvent(fadeEndedEvent)
		return
	end
	
	if (async == nil) then
		async = DEFAULT_ASYNC
	end
	
	-- If already fading, stop fading so we can prioritize this new fade:
	if (currentTween) then
		currentTween:Cancel()
		currentTween = nil
	end
	
	-- Fire Started event:
	self:FireEvent(fadeStartedEvent)
	
	local deltaTransparency = (toTransparency - fromTransparency)
	
	-- Fade operation:
	local tweenInfo = TweenInfo.new(
		(duration or DEFAULT_DURATION),
		easingStyle,
		(fromTransparency > toTransparency and Enum.EasingDirection.In or Enum.EasingDirection.Out)
	)
	currentTween = Tween.new(tweenInfo, function(ratio)
		local transparency = (fromTransparency + (deltaTransparency * ratio))
		fade.BackgroundTransparency = transparency
		label.TextTransparency = transparency
	end)
	
	-- Start fading:
	currentTween:Play()
	
	-- Await fade to end, then fire Ended event:
	local function AwaitEnd()
		currentTween.Completed:Wait()
		self:FireEvent(fadeEndedEvent)
	end
	
	if (async) then
		coroutine.wrap(AwaitEnd)()
	else
		AwaitEnd()
	end
	
end


function Fade:SetEasingStyle(style)
	assert(typeof(style) == "EnumItem", "Argument must be of type EnumItem")
	easingStyle = style
end


function Fade:GetScreenGui()
	return fadeGui
end


function Fade:GetFrame()
	return fade
end


function Fade:GetLabel()
	return label
end


function Fade:Start()
	fadeGui.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
end


function Fade:Init()
	Tween = self.Modules.Tween
	self:RegisterEvent(fadeStartedEvent)
	self:RegisterEvent(fadeEndedEvent)
end


return Fade
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB6434974C2D34D59A4B4FCCCF6AE53BA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TaskScheduler</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- Author: EchoReaper
-- Roblox Link: https://www.roblox.com/Task-Scheduler-item?id=348019935
-- Publically released January 25, 2016

-- Changes made from EchoReaper's version:
	-- GetCurrentFPS() method removed
	-- FPS is only tracked when the 'Loop' function is running for performance reasons
	-- Styled code in consistency with the rest of the AeroGameFramework codebase

--[[
	
	local scheduler = TaskScheduler:CreateScheduler(targetedMinimumFPS)
	
	scheduler:QueueTask(function)
	scheduler:Pause()
	scheduler:Resume()
	scheduler:Destroy()
	
--]]




local TaskScheduler = {}

local lastIteration
local frameUpdateTable = {}

local runService = game:GetService("RunService")

--[[
	param targetFps  Task scheduler won't run a task if it'd make the FPS drop below this amount
					 (WARNING) this only holds true if it is used properly. If you try to complete 10 union operations
					 at once in a single task then of course your FPS is going to drop -- queue the union operations
					 up one at a time so the task scheduler can do its job.
					
					
	returns scheduler
		method Pause      Pauses the scheduler so it won't run tasks. Tasks may still be added while the scheduler is
						  paused. They just won't be touched until it's resumed. Performance efficient -- disables
						  execution loop entirely until scheduler is resumed.
		
		method Resume     Resumes the paused scheduler.
		
		method Destroy    Destroys the scheduler so it can't be used anymore.
		
		method QueueTask  Queues a task for automatic execution.
			param callback  function (task) to be run.
	
	Example usage:
	
	local scheduler = TaskScheduler:CreateScheduler(60)
	local totalOperations = 0
	local paused
	for i=1,100 do
		scheduler:QueueTask(function()
			local partA = Instance.new("Part", workspace)
			local partB = Instance.new("Part", workspace)
			plugin:Union({partA, partB}):Destroy()
			totalOperations = totalOperations + 1
			print("Times unioned:", totalOperations)
			if (totalOperations == 50) then
				scheduler:Pause()
				paused = true
			end
		end)
	end
	
	repeat wait() until paused
	wait(2)
	scheduler:Resume()
--]]


function TaskScheduler:CreateScheduler(targetFps)
	
	local scheduler = {}
	local queue = {}
	local sleeping = true
	local paused
	
	local updateFrameTableEvent = nil
	
	local start = tick()
	runService.RenderStepped:Wait()
	
	local function UpdateFrameTable()
		lastIteration = tick()
		for i = #frameUpdateTable,1,-1 do
			frameUpdateTable[i + 1] = ((frameUpdateTable[i] >= (lastIteration - 1)) and frameUpdateTable[i] or nil)
		end
		frameUpdateTable[1] = lastIteration
	end

	local function Loop()
		updateFrameTableEvent = runService.RenderStepped:Connect(UpdateFrameTable)
		while (true) do
			if (sleeping) then break end
			local fps = (((tick() - start) >= 1 and #frameUpdateTable) or (#frameUpdateTable / (tick() - start)))
			if (fps >= targetFps and (tick() - frameUpdateTable[1]) < (1 / targetFps)) then
				if (#queue > 0) then
					queue[1]()
					table.remove(queue, 1)
				else
					sleeping = true
					break
				end
			else
				runService.RenderStepped:Wait()
			end
		end
		updateFrameTableEvent:Disconnect()
		updateFrameTableEvent = nil
	end

	function scheduler.Pause(_s)
		paused = true
		sleeping = true
	end
	
	function scheduler.Resume(_s)
		if (paused) then
			paused = false
			sleeping = false
			Loop()
		end
	end
	
	function scheduler.Destroy(_s)
		scheduler:Pause()
		for i in pairs(scheduler) do
			scheduler[i] = nil
		end
		setmetatable(scheduler, {
			__index = function()
				error("Attempt to use destroyed scheduler")
			end;
			__newindex = function()
				error("Attempt to use destroyed scheduler")
			end;
		})
	end
	
	function scheduler.QueueTask(_s, callback)
		queue[#queue + 1] = callback
		if (sleeping and not paused) then
			sleeping = false
			Loop()
		end
	end
	
	return scheduler
	
end


return TaskScheduler]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE164D03D39B344298B62C3EF9BA74625">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">UserInput</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- User Input
-- Stephen Leitnick
-- January 2, 2018

--[[
	
	UserInput simply encapsulates all user input modules.
	
	UserInput.Preferred
		- Keyboard
		- Mouse
		- Gamepad
		- Touch
	
	UserInput:Get(inputModuleName)
	UserInput:GetPreferred()

	UserInput.PreferredChanged(preferred)
	
	
	Example:
	
	local keyboard = userInput:Get("Keyboard")
	keyboard.KeyDown:Connect(function(key) end)
	
--]]



local UserInput = {}

UserInput.HideMouse = false

UserInput.Preferred = {
	Keyboard = 0;
	Mouse = 1;
	Gamepad = 2;
	Touch = 3;
}
UserInput._preferred = nil

local modules = {}
local userInput = game:GetService("UserInputService")


function UserInput:Get(moduleName)
	return modules[moduleName]
end


function UserInput:Init()

	for _,obj in ipairs(script:GetChildren()) do
		if (obj:IsA("ModuleScript")) then
			local module = require(obj)
			self:WrapModule(module)
			modules[obj.Name] = module
		end
	end
	
	local function SetMouseIconEnabled(enabled)
		if (self.HideMouse) then
			userInput.MouseIconEnabled = enabled
		end
	end

	local function ChangePreferred(newPreferred)
		if (self._preferred ~= newPreferred) then
			self._preferred = newPreferred
			self.PreferredChanged:Fire(newPreferred)
			if (newPreferred == self.Preferred.Mouse or newPreferred == self.Preferred.Keyboard) then
				SetMouseIconEnabled(true)
			else
				SetMouseIconEnabled(false)
			end
		end
	end

	local function LastInputTypeChanged(lastInputType)
		if (lastInputType.Name:match("^Mouse")) then
			ChangePreferred(self.Preferred.Mouse)
		elseif (lastInputType == Enum.UserInputType.Keyboard or lastInputType == Enum.UserInputType.TextInput) then
			ChangePreferred(self.Preferred.Keyboard)
		elseif (lastInputType.Name:match("^Gamepad")) then
			ChangePreferred(self.Preferred.Gamepad)
		elseif (lastInputType == Enum.UserInputType.Touch) then
			ChangePreferred(self.Preferred.Touch)
		end
	end

	userInput.LastInputTypeChanged:Connect(LastInputTypeChanged)
	self.PreferredChanged = self.Shared.Event.new()

	if (game:GetService("GuiService"):IsTenFootInterface()) then
		ChangePreferred(self.Preferred.Gamepad)
	elseif (userInput.TouchEnabled) then
		ChangePreferred(self.Preferred.Touch)
	else
		ChangePreferred(self.Preferred.Keyboard)
	end

end


function UserInput:GetPreferred()
	return self._preferred
end


return UserInput
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX4DE84D9C8C2C45CDB92358FBAF4F1928">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Gamepad</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[-- Gamepad
-- Stephen Leitnick
-- December 28, 2017

--[[
	
	gamepad = Gamepad.new(gamepadUserInputType)
	
	Boolean      gamepad:IsDown(keyCode)
	Boolean      gamepad:IsConnected()
	InputObject  gamepad:GetState(keyCode)
	Void         gamepad:SetMotor(motor, value)
	Void         gamepad:StopMotor(motor)
	Void         gamepad:StopAllMotors()
	Boolean      gamepad:IsMotorSupported(motor)
	Boolean      gamepad:IsVibrationSupported()
	Float        gamepad:GetMotorValue(motor)
	Float        gamepad:ApplyDeadzone(value, deadzoneThreshold)
	
	gamepad.ButtonDown(keyCode)
	gamepad.ButtonUp(keyCode)
	gamepad.Changed(keyCode, input)
	gamepad.Connected()
	gamepad.Disconnected()
	
--]]



local Gamepad = {}
Gamepad.__index = Gamepad

local gamepadsByInputType = {}

local userInput = game:GetService("UserInputService")
local hapticService = game:GetService("HapticService")
local abs = math.abs

local InverseLerp


function Gamepad.new(gamepad)
	
	if (gamepadsByInputType[gamepad]) then
		return gamepadsByInputType[gamepad]
	end
	
	local self = setmetatable({
		_gamepadInput = gamepad;
		_state = {};
		_isConnected = false;
	}, Gamepad)
	
	self.ButtonDown   = self.Shared.Event.new()
	self.ButtonUp     = self.Shared.Event.new()
	self.Changed      = self.Shared.Event.new()
	self.Connected    = self.Shared.Event.new()
	self.Disconnected = self.Shared.Event.new()
	
	self._listeners = self.Shared.ListenerList.new()
	
	if (userInput:GetGamepadConnected(gamepad)) then
		self._isConnected = true
		self:ConnectAll()
	end
	
	-- Connected:
	userInput.GamepadConnected:Connect(function(gamepadNum)
		if (gamepadNum == gamepad) then
			self._isConnected = true
			self:ConnectAll()
			self.Connected:Fire()
		end
	end)
	
	-- Disconnected:
	userInput.GamepadDisconnected:Connect(function(gamepadNum)
		if (gamepadNum == gamepad) then
			self._isConnected = false
			self:DisconnectAll()
			self.Disconnected:Fire()
		end
	end)
	
	-- Map InputObject states to corresponding KeyCodes:
	for _,input in ipairs(userInput:GetGamepadState(gamepad)) do
		self._state[input.KeyCode] = input
	end
	
	gamepadsByInputType[gamepad] = self
	
	return self
	
end


function Gamepad:ConnectAll()
	
	-- Input Began:
	self._listeners:Connect(userInput.InputBegan, function(input, processed)
		if (processed) then return end
		if (input.UserInputType == self._gamepadInput) then
			self.ButtonDown:Fire(input.KeyCode)
		end
	end)
	
	-- Input Ended:
	self._listeners:Connect(userInput.InputEnded, function(input, _processed)
		if (input.UserInputType == self._gamepadInput) then
			self.ButtonUp:Fire(input.KeyCode)
		end
	end)
	
	-- Input Changed:
	self._listeners:Connect(userInput.InputChanged, function(input, _processed)
		if (input.UserInputType == self._gamepadInput) then
			self.Changed:Fire(input.KeyCode, input)
		end
	end)
	
end


function Gamepad:DisconnectAll()
	self._listeners:DisconnectAll()
end


function Gamepad:IsDown(keyCode)
	return userInput:IsGamepadButtonDown(self._gamepadInput, keyCode)
end


function Gamepad:IsConnected()
	return self._isConnected
end


function Gamepad:GetState(keyCode)
	return self._state[keyCode]
end


function Gamepad:SetMotor(motor, value)
	hapticService:SetMotor(self._gamepadInput, motor, value)
end


function Gamepad:IsMotorSupported(motor)
	return hapticService:IsMotorSupported(self._gamepadInput, motor)
end


function Gamepad:IsVibrationSupported()
	return hapticService:IsVibrationSupported(self._gamepadInput)
end


function Gamepad:StopMotor(motor)
	self:SetMotor(motor, 0)
end


function Gamepad:GetMotorValue(motor)
	return hapticService:GetMotor(self._gamepadInput, motor)
end


function Gamepad:StopAllMotors()
	for _,motor in ipairs(Enum.VibrationMotor:GetEnumItems()) do
		self:StopMotor(motor)
	end
end


function Gamepad:ApplyDeadzone(value, deadzoneThreshold)
	if (abs(value) < deadzoneThreshold) then
		return 0
	elseif (value > 0) then
		return InverseLerp(value, deadzoneThreshold, 1)
	else
		return InverseLerp(value, deadzoneThreshold, -1)
	end
end


function Gamepad:Start()
	
end


function Gamepad:Init()
	InverseLerp = self.Shared.NumberUtil.InverseLerp
end


return Gamepad
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX007B1AB11F354A49B963F7B519FD7BB3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Keyboard</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[-- Keyboard
-- Stephen Leitnick
-- December 28, 2017

--[[
	
	Boolean   Keyboard:IsDown(keyCode)
	Boolean   Keyboard:AreAllDown(keyCodes...)
	Boolean   Keyboard:AreAnyDown(keyCodes...)
	
	Keyboard.KeyDown(keyCode)
	Keyboard.KeyUp(keyCode)
	
--]]



local Keyboard = {}

local userInput = game:GetService("UserInputService")


function Keyboard:IsDown(keyCode)
	return userInput:IsKeyDown(keyCode)
end


function Keyboard:AreAllDown(...)
	for _,keyCode in pairs{...} do
		if (not userInput:IsKeyDown(keyCode)) then
			return false
		end
	end
	return true
end


function Keyboard:AreAnyDown(...)
	for _,keyCode in pairs{...} do
		if (userInput:IsKeyDown(keyCode)) then
			return true
		end
	end
	return false
end


function Keyboard:Start()
	
end


function Keyboard:Init()
	
	self.KeyDown = self.Shared.Event.new()
	self.KeyUp = self.Shared.Event.new()
	
	userInput.InputBegan:Connect(function(input, processed)
		if (processed) then return end
		if (input.UserInputType == Enum.UserInputType.Keyboard) then
			self.KeyDown:Fire(input.KeyCode)
		end
	end)
	
	userInput.InputEnded:Connect(function(input, processed)
		if (processed) then return end
		if (input.UserInputType == Enum.UserInputType.Keyboard) then
			self.KeyUp:Fire(input.KeyCode)
		end
	end)
	
end


return Keyboard]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX512B87893FC44361A0CEA4FEE67055CD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Mobile</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[-- Mobile
-- Stephen Leitnick
-- December 28, 2017

--[[

	Mobile:GetDeviceAcceleration()
	Mobile:GetDeviceGravity()
	Mobile:GetDeviceRotation()
	
	Mobile.TouchStarted(position)
	Mobile.TouchEnded(position)
	Mobile.TouchMoved(position, delta)
	Mobile.TouchTapInWorld(position)
	Mobile.TouchPinch(touchPositions, scale, velocity, state)
	Mobile.TouchLongPress(touchPositions, state)
	Mobile.TouchPan(touchPositions, totalTranslation, velocity, state)
	Mobile.TouchRotate(touchPositions, rotation, velocity, state)
	Mobile.TouchSwipe(swipeDirection, numberOfTouches)
	Mobile.TouchTap(touchPositions)
	Mobile.DeviceAccelerationChanged(acceleration)
	Mobile.DeviceGravityChanged(gravity)
	Mobile.DeviceRotationChanged(rotation, cframe)
	
--]]



local Mobile = {}

local RAY = Ray.new
local workspace = workspace

local userInput = game:GetService("UserInputService")
local cam = workspace.CurrentCamera


function Mobile:GetRay(position)
	local viewportMouseRay = cam:ViewportPointToRay(position.X, position.Y)
	return RAY(viewportMouseRay.Origin, viewportMouseRay.Direction * 999)
end


function Mobile:Cast(position, ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
	return workspace:FindPartOnRay(self:GetRay(position), ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
end


function Mobile:CastWithIgnoreList(position, ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
	return workspace:FindPartOnRayWithIgnoreList(self:GetRay(position), ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
end


function Mobile:CastWithWhitelist(position, whitelistDescendantsTable, ignoreWater)
	return workspace:FindPartOnRayWithWhitelist(self:GetRay(position), whitelistDescendantsTable, ignoreWater)
end


function Mobile:Start()
	
end


function Mobile:Init()
	
	self.TouchStarted = self.Shared.Event.new()
	self.TouchEnded = self.Shared.Event.new()
	self.TouchMoved = self.Shared.Event.new()
	self.TouchTapInWorld = self.Shared.Event.new()
	self.TouchPinch = self.Shared.Event.new()
	self.TouchLongPress = self.Shared.Event.new()
	self.TouchPan = self.Shared.Event.new()
	self.TouchRotate = self.Shared.Event.new()
	self.TouchSwipe = self.Shared.Event.new()
	self.TouchTap = self.Shared.Event.new()
	
	userInput.TouchStarted:Connect(function(input, processed)
		if (processed) then return end
		self.TouchStarted:Fire(input.Position)
	end)
	
	userInput.TouchEnded:Connect(function(input, _processed)
		self.TouchEnded:Fire(input.Position)
	end)
	
	userInput.TouchMoved:Connect(function(input, processed)
		if (processed) then return end
		self.TouchMoved:Fire(input.Position, input.Delta)
	end)
	
	userInput.TouchTapInWorld:Connect(function(position, processed)
		if (processed) then return end
		self.TouchTapInWorld:Fire(position)
	end)
	
	userInput.TouchPinch:Connect(function(touchPositions, scale, velocity, state, processed)
		if (processed) then return end
		self.TouchPinch:Fire(touchPositions, scale, velocity, state)
	end)

	userInput.TouchLongPress:Connect(function(touchPositions, state, processed)
		if (processed) then return end
		self.TouchLongPress:Fire(touchPositions, state)
	end)

	userInput.TouchPan:Connect(function(touchPositions, totalTranslation, velocity, state, processed)
		if (processed) then return end
		self.TouchPan:Fire(touchPositions, totalTranslation, velocity, state)
	end)

	userInput.TouchRotate:Connect(function(touchPositions, rotation, velocity, state, processed)
		if (processed) then return end
		self.TouchRotate:Fire(touchPositions, rotation, velocity, state)
	end)

	userInput.TouchSwipe:Connect(function(swipeDirection, numberOfTouches, processed)
		if (processed) then return end
		self.TouchSwipe:Fire(swipeDirection, numberOfTouches)
	end)

	userInput.TouchTap:Connect(function(touchPositions, processed)
		if (processed) then return end
		self.TouchTap:Fire(touchPositions)
	end)

	self.GetDeviceAcceleration = userInput.GetDeviceAcceleration
	self.GetDeviceGravity = userInput.GetDeviceGravity
	self.GetDeviceRotation = userInput.GetDeviceRotation
	self.DeviceAccelerationChanged = userInput.DeviceAccelerationChanged
	self.DeviceGravityChanged = userInput.DeviceGravityChanged
	self.DeviceRotationChanged = userInput.DeviceRotationChanged
	
end


return Mobile
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE228CD9391EC42418363D41BD1C13084">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Mouse</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[-- Mouse
-- Stephen Leitnick
-- December 28, 2017

--[[
	
	Vector2   Mouse:GetPosition()
	Vector2   Mouse:GetDelta()
	Void      Mouse:Lock()
	Void      Mouse:LockCenter()
	Void      Mouse:Unlock()
	Ray       Mouse:GetRay(distance)
	Ray       Mouse:GetRayFromXY(x, y)
	Void      Mouse:SetMouseIcon(iconId)
	Void      Mouse:SetMouseIconEnabled(isEnabled)
	Boolean   Mouse:IsMouseIconEnabled()
	Boolean   Mouse:IsButtonPressed(mouseButton)
	Many      Mouse:Cast(ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
	Many      Mouse:CastWithIgnoreList(ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
	Many      Mouse:CastWithWhitelist(whitelistDescendantsTable, ignoreWater)
	
	Mouse.LeftDown()
	Mouse.LeftUp()
	Mouse.RightDown()
	Mouse.RightUp()
	Mouse.MiddleDown()
	Mouse.MiddleUp()
	Mouse.Moved()
	Mouse.Scrolled(amount)
	
--]]



local Mouse = {}

local playerMouse = game:GetService("Players").LocalPlayer:GetMouse()
local userInput = game:GetService("UserInputService")
local cam = workspace.CurrentCamera

local workspace = workspace
local RAY = Ray.new

local RAY_DISTANCE = 999


function Mouse:GetPosition()
	return userInput:GetMouseLocation()
end


function Mouse:GetDelta()
	return userInput:GetMouseDelta()
end


function Mouse:Lock()
	userInput.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
end


function Mouse:LockCenter()
	userInput.MouseBehavior = Enum.MouseBehavior.LockCenter
end


function Mouse:Unlock()
	userInput.MouseBehavior = Enum.MouseBehavior.Default
end


function Mouse:SetMouseIcon(iconId)
	playerMouse.Icon = (iconId and ("rbxassetid://" .. iconId) or "")
end


function Mouse:SetMouseIconEnabled(enabled)
	userInput.MouseIconEnabled = enabled
end


function Mouse:IsMouseIconEnabled()
	return userInput.MouseIconEnabled
end


function Mouse:IsButtonPressed(mouseButton)
	return userInput:IsMouseButtonPressed(mouseButton)
end


function Mouse:GetRay(distance)
	local mousePos = userInput:GetMouseLocation()
	local viewportMouseRay = cam:ViewportPointToRay(mousePos.X, mousePos.Y)
	return RAY(viewportMouseRay.Origin, viewportMouseRay.Direction * distance)
end


function Mouse:GetRayFromXY(x, y)
	local viewportMouseRay = cam:ViewportPointToRay(x, y)
	return RAY(viewportMouseRay.Origin, viewportMouseRay.Direction)
end


function Mouse:Cast(ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
	return workspace:FindPartOnRay(self:GetRay(RAY_DISTANCE), ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
end


function Mouse:CastWithIgnoreList(ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
	return workspace:FindPartOnRayWithIgnoreList(self:GetRay(RAY_DISTANCE), ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
end


function Mouse:CastWithWhitelist(whitelistDescendantsTable, ignoreWater)
	return workspace:FindPartOnRayWithWhitelist(self:GetRay(RAY_DISTANCE), whitelistDescendantsTable, ignoreWater)
end


function Mouse:Start()
	
end


function Mouse:Init()
	
	self.LeftDown   = self.Shared.Event.new()
	self.LeftUp     = self.Shared.Event.new()
	self.RightDown  = self.Shared.Event.new()
	self.RightUp    = self.Shared.Event.new()
	self.MiddleDown = self.Shared.Event.new()
	self.MiddleUp   = self.Shared.Event.new()
	self.Moved      = self.Shared.Event.new()
	self.Scrolled   = self.Shared.Event.new()
	
	userInput.InputBegan:Connect(function(input, processed)
		if (processed) then return end
		if (input.UserInputType == Enum.UserInputType.MouseButton1) then
			self.LeftDown:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton2) then
			self.RightDown:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton3) then
			self.MiddleDown:Fire()
		end
	end)
	
	userInput.InputEnded:Connect(function(input, _processed)
		if (input.UserInputType == Enum.UserInputType.MouseButton1) then
			self.LeftUp:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton2) then
			self.RightUp:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton3) then
			self.MiddleUp:Fire()
		end
	end)
	
	userInput.InputChanged:Connect(function(input, processed)
		if (input.UserInputType == Enum.UserInputType.MouseMovement) then
			self.Moved:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseWheel) then
			if (not processed) then
				self.Scrolled:Fire(input.Position.Z)
			end
		end
	end)
	
end


return Mouse
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX6FBCEBC16C45499E94C0A6AB8FFD40A4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Internal</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="LocalScript" referent="RBX622ED2F48B084DC29DCFA6B55F6D1115">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AeroClient</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- Aero Client
-- Stephen Leitnick
-- July 21, 2017



local Aero = {
	Controllers = {};
	Modules = {};
	Shared = {};
	Services = {};
	Player = game:GetService("Players").LocalPlayer;
}

local NO_CACHE = {}

local mt = {__index = Aero}

local controllersFolder = script.Parent.Parent:WaitForChild("Controllers")
local modulesFolder = script.Parent.Parent:WaitForChild("Modules")
local sharedFolder = game:GetService("ReplicatedStorage"):WaitForChild("Aero"):WaitForChild("Shared")

local modulesAwaitingStart = {}

local SpawnNow = require(sharedFolder:WaitForChild("Thread"):Clone()).SpawnNow
local Promise = require(sharedFolder:WaitForChild("Promise"):Clone())


local function PreventEventRegister()
	error("Cannot register event after Init method")
end


function Aero:RegisterEvent(eventName)
	local event = self.Shared.Event.new()
	self._events[eventName] = event
	return event
end


function Aero:FireEvent(eventName, ...)
	self._events[eventName]:Fire(...)
end


function Aero:ConnectEvent(eventName, func)
	return self._events[eventName]:Connect(func)
end


function Aero:WaitForEvent(eventName)
	return self._events[eventName]:Wait()
end


function Aero:WrapModule(tbl)
	assert(type(tbl) == "table", "Expected table for argument")
	tbl._events = {}
	setmetatable(tbl, mt)
	if (type(tbl.Init) == "function" and not tbl.__aeroPreventInit) then
		tbl:Init()
	end
	if (type(tbl.Start) == "function" and not tbl.__aeroPreventStart) then
		if (modulesAwaitingStart) then
			modulesAwaitingStart[#modulesAwaitingStart + 1] = tbl
		else
			SpawnNow(tbl.Start, tbl)
		end
	end
end


local function LoadService(serviceFolder, servicesTbl)
	local service = {}
	servicesTbl[serviceFolder.Name] = service
	for _,v in ipairs(serviceFolder:GetChildren()) do
		if (v:IsA("RemoteEvent")) then
			local event = Aero.Shared.Event.new()
			local fireEvent = event.Fire
			function event:Fire(...)
				v:FireServer(...)
			end
			v.OnClientEvent:Connect(function(...)
				fireEvent(event, ...)
			end)
			service[v.Name] = event
		elseif (v:IsA("RemoteFunction")) then
			local cacheTTL = v:FindFirstChild("Cache")
			if (cacheTTL) then
				cacheTTL = cacheTTL.Value
				local methodName = v.Name
				local cache = NO_CACHE
				local lastCacheTime = 0
				local fetchingPromise
				service[methodName] = function(self, ...)
					local now = tick()
					if (fetchingPromise) then
						local _,c = fetchingPromise:Await()
						return table.unpack(c)
					elseif (cache == NO_CACHE or (cacheTTL > 0 and (now - lastCacheTime) > cacheTTL)) then
						lastCacheTime = now
						local args = table.pack(...)
						fetchingPromise = Promise.Async(function(resolve, _reject)
							resolve(table.pack(v:InvokeServer(table.unpack(args))))
						end)
						local success, _cache = fetchingPromise:Await()
						if (success) then
							cache = _cache
						end
						fetchingPromise = nil
						return table.unpack(_cache)
					end
					return table.unpack(cache)
				end
			else
				service[v.Name] = function(self, ...)
					return v:InvokeServer(...)
				end
			end
		end
	end
	return service
end


local function LoadServices()
	local remoteServices = game:GetService("ReplicatedStorage"):WaitForChild("Aero"):WaitForChild("AeroRemoteServices")
	local function LoadAllServices(folder, servicesTbl)
		for _,serviceFolder in ipairs(folder:GetChildren()) do
			if (serviceFolder:IsA("Folder")) then
				local service = LoadService(serviceFolder, servicesTbl)
				if (next(service) == nil) then
					LoadAllServices(serviceFolder, service)
				end
			end
		end
	end
	LoadAllServices(remoteServices, Aero.Services)
end


-- Setup table to load modules on demand:
local function LazyLoadSetup(tbl, folder)
	setmetatable(tbl, {
		__index = function(t, i)
			local child = folder[i]
			if (child:IsA("ModuleScript")) then
				local obj = require(child)
				rawset(t, i, obj)
				if (type(obj) == "table") then
					-- only wrap module if it's actually a table, and not a table disguised as a function
					local objMetatable = getmetatable(obj)
					if (not (objMetatable and objMetatable.__call)) then
						Aero:WrapModule(obj)
					end
				end
				return obj
			elseif (child:IsA("Folder")) then
				local nestedTbl = {}
				rawset(t, i, nestedTbl)
				LazyLoadSetup(nestedTbl, child)
				return nestedTbl
			end
		end;
	})
end


local function LoadController(module, controllersTbl)
	local controller = require(module)
	controllersTbl[module.Name] = controller
	controller._events = {}
	setmetatable(controller, mt)
end


local function InitController(controller)
	if (type(controller.Init) == "function") then
		controller:Init()
	end
	controller.RegisterEvent = PreventEventRegister
end


local function StartController(controller)
	-- Start controllers on separate threads:
	if (type(controller.Start) == "function") then
		SpawnNow(controller.Start, controller)
	end
end


local function Init()
	
	-- Load controllers:
	local function LoadAllControllers(parent, controllersTbl)
		for _,child in ipairs(parent:GetChildren()) do
			if (child:IsA("ModuleScript")) then
				LoadController(child, controllersTbl)
			elseif (child:IsA("Folder")) then
				local tbl = {}
				controllersTbl[child.Name] = tbl
				LoadAllControllers(child, tbl)
			end
		end
	end
	
	-- Initialize controllers:
	local function InitAllControllers(controllers)
		-- Collect all controllers:
		local controllerTables = {}
		local function CollectControllers(_controllers)
			for _,controller in pairs(_controllers) do
				if (getmetatable(controller) == mt) then
					controllerTables[#controllerTables + 1] = controller
				else
					CollectControllers(controller)
				end
			end
		end
		CollectControllers(controllers)
		-- Sort controllers by optional __aeroOrder field:
		table.sort(controllerTables, function(a, b)
			local aOrder = (type(a.__aeroOrder) == "number" and a.__aeroOrder or math.huge)
			local bOrder = (type(b.__aeroOrder) == "number" and b.__aeroOrder or math.huge)
			return (aOrder < bOrder)
		end)
		-- Initialize controllers:
		for _,controller in ipairs(controllerTables) do
			InitController(controller)
		end
	end
	
	-- Start controllers:
	local function StartAllControllers(controllers)
		for _,controller in pairs(controllers) do
			if (getmetatable(controller) == mt) then
				StartController(controller)
			else
				StartAllControllers(controller)
			end
		end
	end

	-- Start modules that were already loaded:
	local function StartLoadedModules()
		for _,tbl in pairs(modulesAwaitingStart) do
			SpawnNow(tbl.Start, tbl)
		end
		modulesAwaitingStart = nil
	end

	------------------------------------------------------
	
	-- Lazy load modules:
	LazyLoadSetup(Aero.Modules, modulesFolder)
	LazyLoadSetup(Aero.Shared, sharedFolder)
	
	-- Load server-side services:
	LoadServices()

	-- Load, init, and start controllers:
	LoadAllControllers(controllersFolder, Aero.Controllers)
	InitAllControllers(Aero.Controllers)
	StartAllControllers(Aero.Controllers)
	StartLoadedModules()

	-- Expose client framework globally:
	_G.Aero = Aero
	
end


Init()]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXFAD0FF67597241BAA8109464460B4455">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Modules</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX314E2636B7CE4EAD85C714BEE11C053D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraShaker</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- Camera Shaker
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShaker.CameraShakeInstance
	CameraShaker.Presets
	
	cameraShaker = CameraShaker.new(renderPriority, callbackFunction)
	
	CameraShaker:Start()
	CameraShaker:Stop()
	CameraShaker:StopSustained([fadeOutTime])
	CameraShaker:Shake(shakeInstance)
	CameraShaker:ShakeSustain(shakeInstance)
	CameraShaker:ShakeOnce(magnitude, roughness [, fadeInTime, fadeOutTime, posInfluence, rotInfluence])
	CameraShaker:StartShake(magnitude, roughness [, fadeInTime, posInfluence, rotInfluence])
	
	
	
	EXAMPLE:
	
		local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCFrame)
			camera.CFrame = playerCFrame * shakeCFrame
		end)
		
		camShake:Start()
		
		-- Explosion shake:
		camShake:Shake(CameraShaker.Presets.Explosion)
		
		wait(1)
		
		-- Custom shake:
		camShake:ShakeOnce(3, 1, 0.2, 1.5)

		-- Sustained shake:
		camShake:ShakeSustain(CameraShaker.Presets.Earthquake)

		-- Stop all sustained shakes:
		camShake:StopSustained(1) -- Argument is the fadeout time (defaults to the same as fadein time if not supplied)

		-- Stop only one sustained shake:
		shakeInstance = camShake:ShakeSustain(CameraShaker.Presets.Earthquake)
		wait(2)
		shakeInstance:StartFadeOut(1) -- Argument is the fadeout time
	
	
	NOTE:
	
		This was based entirely on the EZ Camera Shake asset for Unity3D. I was given written
		permission by the developer, Road Turtle Games, to port this to Roblox.
		
		Original asset link: https://assetstore.unity.com/packages/tools/camera/ez-camera-shake-33148

		GitHub repository: https://github.com/Sleitnick/RbxCameraShaker
	
	
--]]



local CameraShaker = {}
CameraShaker.__index = CameraShaker
CameraShaker.__aeroPreventStart = true

local profileBegin = debug.profilebegin
local profileEnd = debug.profileend
local profileTag = "CameraShakerUpdate"

local V3 = Vector3.new
local CF = CFrame.new
local ANG = CFrame.Angles
local RAD = math.rad
local v3Zero = V3()

local CameraShakeInstance = require(script.CameraShakeInstance)
local CameraShakeState = CameraShakeInstance.CameraShakeState

local defaultPosInfluence = V3(0.15, 0.15, 0.15)
local defaultRotInfluence = V3(1, 1, 1)

local http = game:GetService("HttpService")


CameraShaker.CameraShakeInstance = CameraShakeInstance
CameraShaker.Presets = require(script.CameraShakePresets)


function CameraShaker.new(renderPriority, callback)
	
	assert(type(renderPriority) == "number", "RenderPriority must be a number (e.g.: Enum.RenderPriority.Camera.Value)")
	assert(type(callback) == "function", "Callback must be a function")
	
	local self = setmetatable({
		_running = false;
		_renderName = ("CameraShaker" .. http:GenerateGUID(false));
		_renderPriority = renderPriority;
		_posAddShake = v3Zero;
		_rotAddShake = v3Zero;
		_camShakeInstances = {};
		_removeInstances = {};
		_callback = callback;
	}, CameraShaker)
	
	return self
	
end


function CameraShaker:Start()
	if (self._running) then return end
	self._running = true
	local callback = self._callback
	game:GetService("RunService"):BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		profileBegin(profileTag)
		local cf = self:Update(dt)
		profileEnd()
		callback(cf)
	end)
end


function CameraShaker:Stop()
	if (not self._running) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._renderName)
	self._running = false
end


function CameraShaker:StopSustained(duration)
	for _,c in ipairs(self._camShakeInstances) do
		if (c.fadeOutDuration == 0) then
			c:StartFadeOut(duration or c.fadeInDuration)
		end
	end
end


function CameraShaker:Update(dt)
	
	local posAddShake = v3Zero
	local rotAddShake = v3Zero
	
	local instances = self._camShakeInstances
	
	-- Update all instances:
	for i = 1,#instances do
		
		local c = instances[i]
		local state = c:GetState()
		
		if (state == CameraShakeState.Inactive and c.DeleteOnInactive) then
			self._removeInstances[#self._removeInstances + 1] = i
		elseif (state ~= CameraShakeState.Inactive) then
			local shake = c:UpdateShake(dt)
			posAddShake = posAddShake + (shake * c.PositionInfluence)
			rotAddShake = rotAddShake + (shake * c.RotationInfluence)
		end
		
	end
	
	-- Remove dead instances:
	for i = #self._removeInstances,1,-1 do
		local instIndex = self._removeInstances[i]
		table.remove(instances, instIndex)
		self._removeInstances[i] = nil
	end
	
	return CF(posAddShake) *
			ANG(0, RAD(rotAddShake.Y), 0) *
			ANG(RAD(rotAddShake.X), 0, RAD(rotAddShake.Z))
	
end


function CameraShaker:Shake(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:ShakeSustain(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	shakeInstance:StartFadeIn(shakeInstance.fadeInDuration)
	return shakeInstance
end


function CameraShaker:ShakeOnce(magnitude, roughness, fadeInTime, fadeOutTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:StartShake(magnitude, roughness, fadeInTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	shakeInstance:StartFadeIn(fadeInTime)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


return CameraShaker]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXDC8BAF8F10B84B82A36760EBFDCD20CA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CameraShakeInstance</string>
								<string name="ScriptGuid">{BD9C1B73-E62A-4EA1-B63F-62CBE47D7890}</string>
								<ProtectedString name="Source"><![CDATA[-- Camera Shake Instance
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	cameraShakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
--]]

--[myelin sheath]
--tee

local CameraShakeInstance = {}
CameraShakeInstance.__index = CameraShakeInstance

local V3 = Vector3.new
local NOISE = math.noise


CameraShakeInstance.CameraShakeState = {
	FadingIn = 0;
	FadingOut = 1;
	Sustained = 2;
	Inactive = 3;
}


function CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
	if (fadeInTime == nil) then fadeInTime = 0 end
	if (fadeOutTime == nil) then fadeOutTime = 0 end
	
	assert(type(magnitude) == "number", "Magnitude must be a number")
	assert(type(roughness) == "number", "Roughness must be a number")
	assert(type(fadeInTime) == "number", "FadeInTime must be a number")
	assert(type(fadeOutTime) == "number", "FadeOutTime must be a number")
	
	local self = setmetatable({
		Magnitude = magnitude;
		Roughness = roughness;
		PositionInfluence = V3();
		RotationInfluence = V3();
		DeleteOnInactive = true;
		roughMod = 1;
		magnMod = 1;
		fadeOutDuration = fadeOutTime;
		fadeInDuration = fadeInTime;
		sustain = (fadeInTime > 0);
		currentFadeTime = (fadeInTime > 0 and 0 or 1);
		tick = Random.new():NextNumber(-100, 100);
		_camShakeInstance = true;
	}, CameraShakeInstance)
	
	return self
	
end


function CameraShakeInstance:UpdateShake(dt)
	
	local _tick = self.tick
	local currentFadeTime = self.currentFadeTime
	
	local offset = V3(
		NOISE(_tick, 0) * 0.5,
		NOISE(0, _tick) * 0.5,
		NOISE(_tick, _tick) * 0.5
	)
	
	if (self.fadeInDuration > 0 and self.sustain) then
		if (currentFadeTime < 1) then
			currentFadeTime = currentFadeTime + (dt / self.fadeInDuration)
		elseif (self.fadeOutDuration > 0) then
			self.sustain = false
		end
	end
	
	if (not self.sustain) then
		currentFadeTime = currentFadeTime - (dt / self.fadeOutDuration)
	end
	
	if (self.sustain) then
		self.tick = _tick + (dt * self.Roughness * self.roughMod)
	else
		self.tick = _tick + (dt * self.Roughness * self.roughMod * currentFadeTime)
	end
	
	self.currentFadeTime = currentFadeTime
	
	return offset * self.Magnitude * self.magnMod * currentFadeTime
	
end


function CameraShakeInstance:StartFadeOut(fadeOutTime)
	if (fadeOutTime == 0) then
		self.currentFadeTime = 0
	end
	self.fadeOutDuration = fadeOutTime
	self.fadeInDuration = 0
	self.sustain = false
end


function CameraShakeInstance:StartFadeIn(fadeInTime)
	if (fadeInTime == 0) then
		self.currentFadeTime = 1
	end
	self.fadeInDuration = fadeInTime or self.fadeInDuration
	self.fadeOutDuration = 0
	self.sustain = true
end


function CameraShakeInstance:GetScaleRoughness()
	return self.roughMod
end


function CameraShakeInstance:SetScaleRoughness(v)
	self.roughMod = v
end


function CameraShakeInstance:GetScaleMagnitude()
	return self.magnMod
end


function CameraShakeInstance:SetScaleMagnitude(v)
	self.magnMod = v
end


function CameraShakeInstance:GetNormalizedFadeTime()
	return self.currentFadeTime
end


function CameraShakeInstance:IsShaking()
	return (self.currentFadeTime > 0 or self.sustain)
end


function CameraShakeInstance:IsFadingOut()
	return ((not self.sustain) and self.currentFadeTime > 0)
end


function CameraShakeInstance:IsFadingIn()
	return (self.currentFadeTime < 1 and self.sustain and self.fadeInDuration > 0)
end


function CameraShakeInstance:GetState()
	if (self:IsFadingIn()) then
		return CameraShakeInstance.CameraShakeState.FadingIn
	elseif (self:IsFadingOut()) then
		return CameraShakeInstance.CameraShakeState.FadingOut
	elseif (self:IsShaking()) then
		return CameraShakeInstance.CameraShakeState.Sustained
	else
		return CameraShakeInstance.CameraShakeState.Inactive
	end
end


return CameraShakeInstance]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAC2FB6409D52490C9D4277C48586F1EE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CameraShakePresets</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[-- Camera Shake Presets
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShakePresets.Bump
	CameraShakePresets.Explosion
	CameraShakePresets.Earthquake
	CameraShakePresets.GentleSway
	CameraShakePresets.BadTrip
	CameraShakePresets.HandheldCamera
	CameraShakePresets.Vibration
	CameraShakePresets.RoughDriving
	
--]]



local CameraShakeInstance = require(script.Parent.CameraShakeInstance)

local CameraShakePresets = {
	
	
	-- A high-magnitude, short, yet smooth shake.
	-- Should happen once.
	Bump = function()
		local c = CameraShakeInstance.new(2.5, 4, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(0.15, 0.15, 0.15)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
	-- An intense and rough shake.
	-- Should happen once.
	Explosion = function()
		local c = CameraShakeInstance.new(5, 10, 0, 1.5)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(4, 1, 1)
		return c
	end;
	
	
	-- A continuous, rough shake
	-- Sustained.
	Earthquake = function()
		local c = CameraShakeInstance.new(0.6, 3.5, 2, 10)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(1, 1, 4)
		return c
	end;
	
	
	-- A gentle left/right/up/down sway. Good for intro screens/landscapes.
	-- Sustained.
	GentleSway = function()
		local c = CameraShakeInstance.new(0.65, 0.08, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(1.20, 0.35, 0.05)
		c.RotationInfluence = Vector3.new(0.02, 0.02, 0.02)
		return c
	end;
	
	
	-- A bizarre shake with a very high magnitude and low roughness.
	-- Sustained.
	BadTrip = function()
		local c = CameraShakeInstance.new(10, 0.15, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0.15)
		c.RotationInfluence = Vector3.new(2, 1, 4)
		return c
	end;
	
	
	-- A subtle, slow shake.
	-- Sustained.
	HandheldCamera = function()
		local c = CameraShakeInstance.new(1, 0.25, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 0.5, 0.5)
		return c
	end;
	
	
	-- A very rough, yet low magnitude shake.
	-- Sustained.
	Vibration = function()
		local c = CameraShakeInstance.new(0.4, 20, 2, 2)
		c.PositionInfluence = Vector3.new(0, 0.15, 0)
		c.RotationInfluence = Vector3.new(1.25, 0, 4)
		return c
	end;
	
	
	-- A slightly rough, medium magnitude shake.
	-- Sustained.
	RoughDriving = function()
		local c = CameraShakeInstance.new(1, 2, 1, 1)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
}


return setmetatable({}, {
	__index = function(_t, i)
		local f = CameraShakePresets[i]
		if (type(f) == "function") then
			return f()
		end
		error("No preset found with index \"" .. i .. "\"")
	end;
})
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX5DFF149A8FFE4FF08B6DD1799C9B03B0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PID</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- PID
-- Stephen Leitnick
-- July 14, 2018

--[[
	
	PID stands for Proportional-Integral-Derivative. It is common practice to use
	a "PID Controller" (like this one) to calculate the desired output to meet a
	certain setpoint or target. For instance, a car's cruise control setting
	might use a PID Controller to calculate the necessary acceleration needed
	to go from the current speed to the desired speed.
	
	
	pid = PID.new(kp, ki, kd)
	
		VOID    pid:SetInput(input [, clampToMinMax])
		VOID    pid:SetTarget(target [, clampToMinMax])
		
		NUMBER  pid:Compute()
		
		VOID    pid:SetTunings(kp, ki, kd)
		VOID    pid:SetSampleTime(sampleTimeMillis)
		VOID    pid:SetOutputLimits(min, max)
		VOID    pid:ClearOutputLimits()
		
		VOID    pid:Run(callbackBefore, callbackAfter)
		VOID    pid:Stop()
		VOID    pid:Pause()
		VOID    pid:Resume()
		
		VOID    pid:Clone()
		
	
	EXAMPLE:
	
		pid = PID.new(0.01, 0.01, -0.01)
		
		pid:Run(
			function()
				pid:SetInput(currentSpeed)
				pid:SetTarget(desiredSpeed)
			end,
			function(output)
				car:SetAcceleration(output)
			end
		)
	
--]]



local PID = {}
PID.__index = PID


local tick = tick
local function millis()
	return tick() * 1000
end


function PID.new(kp, ki, kd)
	
	local self = setmetatable({
		Input = 0;
		Target = 0;
		P = 0;
		I = 0;
		D = 0;
		LastInput = 0;
		ITerm = 0;
		LastError = 0;
		Output = 0;
		SampleTimeMillis = 10;
		LastTime = 0;
		OutMin = -math.huge;
		OutMax = math.huge;
		_paused = false;
	}, PID)
	
	self:SetTunings(kp, ki, kd)
	
	return self
	
end


function PID:SetInput(input, clampToMinMax)
	if (clampToMinMax) then
		self.Input = math.clamp(input, self.OutMin, self.OutMax)
	else
		self.Input = input
	end
end


function PID:SetTarget(target, clampToMinMax)
	if (clampToMinMax) then
		self.Target = math.clamp(target, self.OutMin, self.OutMax)
	else
		self.Target = target
	end
end


function PID:SetTunings(kp, ki, kd)
	self.P = kp
	self.I = ki * self.SampleTimeMillis
	self.D = kd / self.SampleTimeMillis
end


function PID:SetSampleTime(newSampleTime)
	newSampleTime = math.max(newSampleTime, 0)
	local ratio = newSampleTime / self.SampleTimeMillis
	self.I = self.I * ratio
	self.D = self.D / ratio
	self.SampleTimeMillis = newSampleTime
end


function PID:SetOutputLimits(min, max)
	self.OutMin = math.min(min, max)
	self.OutMax = math.max(min, max)
	if (self.Output > self.OutMax) then
		self.Output = self.OutMax
	elseif (self.Output < self.OutMin) then
		self.Output = self.OutMin
	end
	if (self.ITerm > self.OutMax) then
		self.ITerm = self.OutMax
	elseif (self.ITerm < self.OutMin) then
		self.ITerm = self.OutMin
	end
end


function PID:ClearOutputLimits()
	self:SetOutputLimits(-math.huge, math.huge)
end


function PID:Compute()
	
	local now = millis()
	local timeChange = (now - self.LastTime)
	
	if (timeChange > self.SampleTimeMillis) then
	
		local err = self.Target - self.Input
		self.ITerm = math.clamp((self.ITerm + (self.I * err)), self.OutMin, self.OutMax)
		local dInput = (self.Input - self.LastInput)
		
		self.Output = math.clamp((self.P * err) + (self.ITerm) - (self.D * dInput), self.OutMin, self.OutMax)
		
		self.LastError = err
		self.LastInput = self.Input
		self.LastTime = now
		
	end
	
	return self.Output
	
end


function PID:_hookupHeartbeat()
	self._heartbeat = game:GetService("RunService").Heartbeat:Connect(self._callback)
end


function PID:Run(callbackBefore, callbackAfter)
	if (self._running) then
		error("Already running")
		return
	end
	self._running = true
	self._paused = false
	self._callback = function(dt)
		callbackBefore(dt)
		callbackAfter(self:Compute())
	end
	self:_hookupHeartbeat()
end


function PID:Stop()
	if (not self._running) then return end
	self._heartbeat:Disconnect()
	self._heartbeat = nil
	self._callback = nil
	self._running = false
end


function PID:Pause()
	if (self._running and not self._paused) then
		self._paused = true
		self._heartbeat:Disconnect()
	end
end


function PID:Resume()
	if (self._running and self._paused and self._callback) then
		self.LastInput = self.Input
		self.ITerm = math.clamp(self.Output, self.OutMin, self.OutMax)
		self._paused = false
		self:_hookupHeartbeat()
	end
end


function PID:Clone()
	local clone = PID.new(self.P, self.I, self.D)
	clone:SetSampleTime(self.SampleTimeMillis)
	return clone
end


return PID]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC7CD668246AD4DD989A7482D2C743A9E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Smooth</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- Smooth
-- Stephen Leitnick
-- June 3, 2018

--[[
	
	This is a wrapper for the SmoothDamp module. It stores
	all needed variables internally for ease of use.
	
	-------------------------------------------------------------------------

	local smooth = Smooth.new(Vector3 initialValue, Number smoothTime)
	
	smooth.Value
	smooth.Goal
	smooth.SmoothTime
	
	smooth:Update([Vector goal])
	smooth:UpdateAngle([Vector goal])
	smooth:SetMaxSpeed(Number speed)
	smooth:GetMaxSpeed()

	-------------------------------------------------------------------------

	EXAMPLE:

		local smoothPosition = Smooth.new(part.Position, 0.5)

		runService:BindToRenderStep("Example", 0, function()
			local position = smoothPosition:Update(mouse.Hit.p)
			part.Position = position
		end)

--]]



local Smooth = {}
Smooth.__index = Smooth

local SmoothDamp = require(script:WaitForChild("SmoothDamp"))


function Smooth.new(initialValue, smoothTime)

	assert(typeof(initialValue) == "Vector3", "initialValue should be Vector3")
	assert(typeof(smoothTime) == "number", "smoothTime should be a number")
	assert(smoothTime >= 0, "smoothTime must be a positive number")
	
	local self = setmetatable({
		Value = initialValue;
		Goal = initialValue;
		SmoothTime = smoothTime;
	}, Smooth)
	
	self._smoothDamp = SmoothDamp.new()
	
	return self
	
end


function Smooth:Update(goal)
	if (goal) then
		self.Goal = goal
	else
		goal = self.Goal
	end
	local value = self._smoothDamp:Update(self.Value, goal, self.SmoothTime)
	self.Value = value
	return value
end


function Smooth:UpdateAngle(goal)
	if (goal) then
		self.Goal = goal
	else
		goal = self.Goal
	end
	local value = self._smoothDamp:UpdateAngle(self.Value, goal, self.SmoothTime)
	self.Value = value
	return value
end


function Smooth:SetMaxSpeed(speed)
	self._smoothDamp.MaxSpeed = speed
end


function Smooth:GetMaxSpeed()
	return self._smoothDamp.MaxSpeed
end


return Smooth]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5BD0A9B1E8FC45B2B7A60C3C2194FE73">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SmoothDamp</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[-- Smooth Damp
-- Stephen Leitnick
-- January 30, 2017

--[[

	local SmoothDamp = require(this)

	smooth = SmoothDamp.new()
	smooth.MaxSpeed
	smooth:Update(currentVector, targetVector, smoothTime)
	smooth:UpdateAngle(currentVector, targetVector, smoothTime)


	Use UpdateAngle if smoothing out angles. The only difference is that
	it makes sure angles wrap properly (in radians). For instance, if
	damping a rotating wheel, UpdateAngle should be used.


	-- Example:

	local smooth = SmoothDamp.new()
	function Update()
		local current = camera.CFrame.p
		local target = (part.CFrame * CFrame.new(0, 5, -10)).p
		local camPos = smooth:Update(current, target, 0.2)
		camera.CFrame = CFrame.new(camPos, part.Position)
	end
--]]


----------------------------------------------------------------------------------------------------------------

local function DeltaAngle(current, target)
	local n = ((target - current) % 6.2831853071796)
	return (n > 3.1415926535898 and (n - 6.2831853071796) or n)
end

local function DeltaAngleV3(p1, p2)
	return Vector3.new(DeltaAngle(p1.X, p2.X), DeltaAngle(p1.Y, p2.Y), DeltaAngle(p1.Z, p2.Z))
end

----------------------------------------------------------------------------------------------------------------

local SmoothDamp = {}
SmoothDamp.__index = SmoothDamp

function SmoothDamp.new()
	return setmetatable({
		MaxSpeed = math.huge;
		_update = tick();
		_velocity = Vector3.new();
	}, SmoothDamp)
end

function SmoothDamp:Update(current, target, smoothTime)
	local currentVelocity = self._velocity
	local now = tick()
	local deltaTime = (now - self._update)
	smoothTime = math.max(0.0001, smoothTime)

	local num = (2 / smoothTime)
	local num2 = (num * deltaTime)
	local d = (1 / (1 + num2 + 0.48 * num2 * num2 + 0.235 * num2 * num2 * num2))

	local vector = (current - target)
	local vector2 = target

	local maxLength = (self.MaxSpeed * smoothTime)
	vector = vector.Magnitude > maxLength and (vector.Unit * maxLength) or vector -- Clamp magnitude.
	target = (current - vector)

	local vector3 = ((currentVelocity + num * vector) * deltaTime)
	currentVelocity = ((currentVelocity - num * vector3) * d)

	local vector4 = (target + (vector + vector3) * d)
	if ((vector2 - current):Dot(vector4 - vector2) > 0) then
		vector4 = vector2
		currentVelocity = ((vector4 - vector2) / deltaTime)
	end

	self._velocity = currentVelocity
	self._update = now
	return vector4
end

function SmoothDamp:UpdateAngle(current, target, smoothTime)
	return self:Update(current, (current + DeltaAngleV3(current, target)), smoothTime)
end

return SmoothDamp
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX286518E98F514677809B6EDBF9D7B1B8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Tween</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- Tween
-- Stephen Leitnick
-- June 21, 2017

--[[
	
	Native:
		
		tween = Tween.FromService(instance, tweenInfo, properties)
		
		See Wiki page on Tween object for methods and such
		
		
	Custom:
	
		tween = Tween.new(tweenInfo, callbackFunction)
		
		tween.TweenInfo
		tween.Callback
		tween.PlaybackState
		
		tween:Play()
		tween:Pause()
		tween:Cancel()
		
		tween.Completed(playbackState)
		tween.PlaybackStateChanged(playbackState)
	
	
	Custom Example:
	
		tween = Tween.new(TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, true, 0), function(n)
			print(n)
		end)
		
		tween:Play()
		tween.Completed:Wait()
	
--]]



local Tween = {}
Tween.__index = Tween


Tween.Easing = require(script:WaitForChild("Easing"))


function Tween.new(tweenInfo, callback)
	
	do
		-- Verify callback is function:
		assert(typeof(callback) == "function", "Callback argument must be a function")
		
		-- Verify tweenInfo:
		local typeOfTweenInfo = typeof(tweenInfo)
		assert(typeOfTweenInfo == "TweenInfo" or typeOfTweenInfo == "table", "TweenInfo must be of type TweenInfo or table")
		
		-- Defaults:
		if (typeOfTweenInfo == "table") then
			if (tweenInfo.Time == nil) then tweenInfo.Time = 1 end
			if (tweenInfo.EasingStyle == nil) then tweenInfo.EasingStyle = Enum.EasingStyle.Quad end
			if (tweenInfo.EasingDirection == nil) then tweenInfo.EasingDirection = Enum.EasingDirection.Out end
			if (tweenInfo.RepeatCount == nil) then tweenInfo.RepeatCount = 0 end
			if (tweenInfo.Reverses == nil) then tweenInfo.Reverses = false end
			if (tweenInfo.DelayTime == nil) then tweenInfo.DelayTime = 0 end
		end
		
	end
	
	local completed = Instance.new("BindableEvent")
	local playbackStateChanged = Instance.new("BindableEvent")
	
	local self = setmetatable({
		
		TweenInfo = tweenInfo;
		Callback = callback;
		PlaybackState = Enum.PlaybackState.Begin;
		Completed = completed.Event;
		PlaybackStateChanged = playbackStateChanged.Event;
		
		_id = "tween_" .. game:GetService("HttpService"):GenerateGUID(false);
		_playing = false;
		_paused = false;
		_completed = completed;
		_playbackStateChanged = playbackStateChanged;
		_elapsedTime = 0;
		_repeated = 0;
		_reversing = false;
		_elapsedDelayTime = 0;
		
	}, Tween)
	
	return self
	
end


function Tween:ResetState()
	self._playing = false
	self._paused = false
	self._elapsedTime = 0
	self._repeated = 0
	self._reversing = false
	self._elapsedDelayTime = 0
end


function Tween:SetPlaybackState(state)
	local lastState = self.PlaybackState
	self.PlaybackState = state
	if (state ~= lastState) then
		self._playbackStateChanged:Fire(state)
	end
end


function Tween:Play()
	
	if (self._playing and not self._paused) then return end
	self._playing = true
	self._paused = false
	
	-- Resolve easing function:
	local easingFunc
	if (typeof(self.TweenInfo) == "TweenInfo") then
		easingFunc = Tween.Easing[self.TweenInfo.EasingDirection.Name][self.TweenInfo.EasingStyle.Name]
	else
		local dir, style
		dir = typeof(self.TweenInfo.EasingDirection) == "EnumItem" and self.TweenInfo.EasingDirection.Name or self.TweenInfo.EasingDirection
		style = typeof(self.TweenInfo.EasingStyle) == "EnumItem" and self.TweenInfo.EasingStyle.Name or self.TweenInfo.EasingStyle
		easingFunc = Tween.Easing[dir][style]
		if (not self.TweenInfo.RepeatCount) then
			self.TweenInfo.RepeatCount = 0
		end
	end
	
	local tick = tick
	
	local elapsed = self._elapsedTime
	local duration = self.TweenInfo.Time
	local last = tick()
	local callback = self.Callback
	local reverses = self.TweenInfo.Reverses
	
	local elapsedDelay = self._elapsedDelayTime
	local durationDelay = self.TweenInfo.DelayTime
	
	local reversing = self._reversing
	
	local function OnCompleted()
		callback(easingFunc(duration, 0, 1, duration))
		game:GetService("RunService"):UnbindFromRenderStep(self._id)
		self.PlaybackState = Enum.PlaybackState.Completed
		self._completed:Fire(self.PlaybackState)
		self:ResetState()
	end
	
	local function IsDelayed(dt)
		if (elapsedDelay >= durationDelay) then return false end
		elapsedDelay = (elapsedDelay + dt)
		self._elapsedDelayTime = elapsedDelay
		if (elapsedDelay < durationDelay) then
			self:SetPlaybackState(Enum.PlaybackState.Delayed)
		else
			self:SetPlaybackState(Enum.PlaybackState.Playing)
		end
		return (elapsedDelay < durationDelay)
	end
	
	-- Tween:
	game:GetService("RunService"):BindToRenderStep(self._id, Enum.RenderPriority.Camera.Value - 1, function()
		local now = tick()
		local dt = (now - last)
		last = now
		if (IsDelayed(dt)) then return end
		elapsed = (elapsed + dt)
		self._elapsedTime = elapsed
		local notDone = (elapsed < duration)
		if (notDone) then
			if (reversing) then
				callback(easingFunc(elapsed, 1, -1, duration))
			else
				callback(easingFunc(elapsed, 0, 1, duration))
			end
		else
			if ((self._repeated < self.TweenInfo.RepeatCount) or reversing) then
				if (reverses) then
					reversing = (not reversing)
					self._reversing = reversing
				end
				if ((not reverses) or (reversing)) then
					self._repeated = (self._repeated + 1)
				end
				if (not reversing) then
					self._elapsedDelayTime = 0
					elapsedDelay = 0
				end
				self._elapsedTime = 0
				elapsed = 0
			else
				OnCompleted()
			end
		end
	end)
	
end


function Tween:Pause()
	if ((not self._playing) or (self._paused)) then return end
	self._paused = true
	self:SetPlaybackState(Enum.PlaybackState.Paused)
	game:GetService("RunService"):UnbindFromRenderStep(self._id)
end


function Tween:Cancel()
	if (not self._playing) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._id)
	self:ResetState()
	self:SetPlaybackState(Enum.PlaybackState.Cancelled)
	self._completed:Fire(self.PlaybackState)
end


function Tween.fromService(...)
	return game:GetService("TweenService"):Create(...)
end


Tween.FromService = Tween.fromService
Tween.New = Tween.new


return Tween]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXD6CD1E3A588E4D8181532F0DDC243CB2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Easing</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[-- Easing
-- Stephen Leitnick
-- June 21, 2017

-- Source: https://github.com/RoStrap/Interpolation/blob/master/EasingFunctions.lua

--[[
	Disclaimer for Robert Penner's Easing Equations license:

	TERMS OF USE - EASING EQUATIONS

	Open source under the BSD License.

	Copyright  2001 Robert Penner
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = beginning value
-- c = change in value same as: ending - beginning
-- d = duration (total time)

-- Where applicable
-- a = amplitude
-- p = period

local sin, cos, asin = math.sin, math.cos, math.asin

local function Linear(t, b, c, d)
	return c * t / d + b
end

local function Smooth(t, b, c, d)
	t = t / d
	return c * t * t * (3 - 2 * t) + b
end

local function Smoother(t, b, c, d)
	t = t / d
	return c * t * t * t * (t * (6 * t - 15) + 10) + b
end

-- Arceusinator's Easing Functions
local function RevBack(t, b, c, d)
	t = 1 - t / d
	return c * (1 - (sin(t * 1.5707963267948965579989817342720925807952880859375) + (sin(t * 3.14159265358979311599796346854418516159057617187) * (cos(t * 3.14159265358979311599796346854418516159057617187) + 1) * 0.5))) + b
end

local function RidiculousWiggle(t, b, c, d)
	t = t / d
	return c * sin(sin(t * 3.14159265358979311599796346854418516159057617187) * 1.5707963267948965579989817342720925807952880859375) + b
end

-- YellowTide's Easing Functions
local function Spring(t, b, c, d)
	t = t / d
	return (1 + (-2.72 ^ (-6.9 * t) * cos(-20.1061929829746759423869661986827850341796875 * t))) * c + b
end

local function SoftSpring(t, b, c, d)
	t = t / d
	return (1 + (-2.72 ^ (-7.5 * t) * cos(-10.05309649148733797119348309934139251708984375 * t))) * c + b
end
-- End of YellowTide's functions

local function InQuad(t, b, c, d)
	t = t / d
	return c * t * t + b
end

local function OutQuad(t, b, c, d)
	t = t / d
	return -c * t * (t - 2) + b
end

local function InOutQuad(t, b, c, d)
	t = t / d * 2
	return t < 1 and c * 0.5 * t * t + b or -c * 0.5 * ((t - 1) * (t - 3) - 1) + b
end

local function OutInQuad(t, b, c, d)
	if t < d * 0.5 then
		t = 2 * t / d
		return -0.5 * c * t * (t - 2) + b
	else
		t, c = ((t * 2) - d) / d, 0.5 * c
		return c * t * t + b + c
	end
end

local function InCubic(t, b, c, d)
	t = t / d
	return c * t * t * t + b
end

local function OutCubic(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t + 1) + b
end

local function InOutCubic(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t + 2) + b
	end
end

local function OutInCubic(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t + 1) + b
	else
		t, c = ((t * 2) - d) / d, c * 0.5
		return c * t * t * t + b + c
	end
end

local function InQuart(t, b, c, d)
	t = t / d
	return c * t * t * t * t + b
end

local function OutQuart(t, b, c, d)
	t = t / d - 1
	return -c * (t * t * t * t - 1) + b
end

local function InOutQuart(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t + b
	else
		t = t - 2
		return -c * 0.5 * (t * t * t * t - 2) + b
	end
end

local function OutInQuart(t, b, c, d)
	if t < d * 0.5 then
		t, c = t * 2 / d - 1, c * 0.5
		return -c * (t * t * t * t - 1) + b
	else
		t, c = ((t * 2) - d) / d, c * 0.5
		return c * t * t * t * t + b + c
	end
end

local function InQuint(t, b, c, d)
	t = t / d
	return c * t * t * t * t * t + b
end

local function OutQuint(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t * t * t + 1) + b
end

local function InOutQuint(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t * t * t + 2) + b
	end
end

local function OutInQuint(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t * t * t + 1) + b
	else
		t, c = ((t * 2) - d) / d, c * 0.5
		return c * t * t * t * t * t + b + c
	end
end

local function InSine(t, b, c, d)
	return -c * cos(t / d * 1.5707963267948965579989817342720925807952880859375) + c + b
end

local function OutSine(t, b, c, d)
	return c * sin(t / d * 1.5707963267948965579989817342720925807952880859375) + b
end

local function InOutSine(t, b, c, d)
	return -c * 0.5 * (cos(3.14159265358979311599796346854418516159057617187 * t / d) - 1) + b
end

local function OutInSine(t, b, c, d)
	c = c * 0.5
	return t < d * 0.5 and c * sin(t * 2 / d * 1.5707963267948965579989817342720925807952880859375) + b or -c * cos(((t * 2) - d) / d * 1.5707963267948965579989817342720925807952880859375) + 2 * c + b
end

local function InExpo(t, b, c, d)
	return t == 0 and b or c * 2 ^ (10 * (t / d - 1)) + b - c * 0.001
end

local function OutExpo(t, b, c, d)
	return t == d and b + c or c * 1.001 * (1 - 2 ^ (-10 * t / d)) + b
end

local function InOutExpo(t, b, c, d)
	t = t / d * 2
	return t == 0 and b or t == 2 and b + c or t < 1 and c * 0.5 * 2 ^ (10 * (t - 1)) + b - c * 0.0005 or c * 0.5 * 1.0005 * (2 - 2 ^ (-10 * (t - 1))) + b
end

local function OutInExpo(t, b, c, d)
	c = c * 0.5
	return t < d * 0.5 and (t * 2 == d and b + c or c * 1.001 * (1 - 2 ^ (-20 * t / d)) + b) or t * 2 - d == 0 and b + c or c * 2 ^ (10 * ((t * 2 - d) / d - 1)) + b + c - c * 0.001
end

local function InCirc(t, b, c, d)
	t = t / d
	return -c * ((1 - t * t) ^ 0.5 - 1) + b
end

local function OutCirc(t, b, c, d)
	t = t / d - 1
	return c * (1 - t * t) ^ 0.5 + b
end

local function InOutCirc(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return -c * 0.5 * ((1 - t * t) ^ 0.5 - 1) + b
	else
		t = t - 2
		return c * 0.5 * ((1 - t * t) ^ 0.5 + 1) + b
	end
end

local function OutInCirc(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * (1 - t * t) ^ 0.5 + b
	else
		t = (t * 2 - d) / d
		return -c * ((1 - t * t) ^ 0.5 - 1) + b + c
	end
end

local function InElastic(t, b, c, d, a, p)
	t = t / d - 1
	p = p or d * 0.3
	return t == -1 and b or t == 0 and b + c or (not a or a < (c >= 0 and c or 0 - c)) and -(c * 2 ^ (10 * t) * sin((t * d - p * 0.25) * 6.28318530717958623199592693708837032318115234375 / p)) + b or -(a * 2 ^ (10 * t) * sin((t * d - p / 6.28318530717958623199592693708837032318115234375 * asin(c / a)) * 6.28318530717958623199592693708837032318115234375 / p)) + b
end

local function OutElastic(t, b, c, d, a, p)
	t = t / d
	p = p or d * 0.3
	return t == 0 and b or t == 1 and b + c or (not a or a < (c >= 0 and c or 0 - c)) and c * 2 ^ (-10 * t) * sin((t * d - p * 0.25) * 6.28318530717958623199592693708837032318115234375 / p) + c + b or a * 2 ^ (-10 * t) * sin((t * d - p / 6.28318530717958623199592693708837032318115234375 * asin(c / a)) * 6.28318530717958623199592693708837032318115234375 / p) + c + b
end

local function InOutElastic(t, b, c, d, a, p)
	if t == 0 then
		return b
	end

	t = t / d * 2 - 1

	if t == 1 then
		return b + c
	end

	p = p or d * 0.45
	a = a or 0

	local s

	if not a or a < (c >= 0 and c or 0 - c) then
		a = c
		s = p * 0.25
	else
		s = p / 6.28318530717958623199592693708837032318115234375 * asin(c / a)
	end

	if t < 1 then
		return -0.5 * a * 2 ^ (10 * t) * sin((t * d - s) * 6.28318530717958623199592693708837032318115234375 / p) + b
	else
		return a * 2 ^ (-10 * t) * sin((t * d - s) * 6.28318530717958623199592693708837032318115234375 / p ) * 0.5 + c + b
	end
end

local function OutInElastic(t, b, c, d, a, p)
	if t < d * 0.5 then
		return OutElastic(t * 2, b, c * 0.5, d, a, p)
	else
		return InElastic(t * 2 - d, b + c * 0.5, c * 0.5, d, a, p)
	end
end

local function InBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d
	return c * t * t * ((s + 1) * t - s) + b
end

local function OutBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d - 1
	return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function InOutBack(t, b, c, d, s)
	s = (s or 1.70158) * 1.525
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * (t * t * ((s + 1) * t - s)) + b
	else
		t = t - 2
		return c * 0.5 * (t * t * ((s + 1) * t + s) + 2) + b
	end
end

local function OutInBack(t, b, c, d, s)
	c = c * 0.5
	s = s or 1.70158
	if t < d * 0.5 then
		t = (t * 2) / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	else
		t = ((t * 2) - d) / d
		return c * t * t * ((s + 1) * t - s) + b + c
	end
end

local function OutBounce(t, b, c, d)
	t = t / d
	if t < 1 / 2.75 then
		return c * (7.5625 * t * t) + b
	elseif t < 2 / 2.75 then
		t = t - (1.5 / 2.75)
		return c * (7.5625 * t * t + 0.75) + b
	elseif t < 2.5 / 2.75 then
		t = t - (2.25 / 2.75)
		return c * (7.5625 * t * t + 0.9375) + b
	else
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end
end

local function InBounce(t, b, c, d)
	return c - OutBounce(d - t, 0, c, d) + b
end

local function InOutBounce(t, b, c, d)
	if t < d * 0.5 then
		return InBounce(t * 2, 0, c, d) * 0.5 + b
	else
		return OutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
	end
end

local function OutInBounce(t, b, c, d)
	if t < d * 0.5 then
		return OutBounce(t * 2, b, c * 0.5, d)
	else
		return InBounce(t * 2 - d, b + c * 0.5, c * 0.5, d)
	end
end

return {
	[Enum.EasingDirection.In.Name] = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = InSine;
		[Enum.EasingStyle.Back.Name] = InBack;
		[Enum.EasingStyle.Quad.Name] = InQuad;
		[Enum.EasingStyle.Quart.Name] = InQuart;
		[Enum.EasingStyle.Quint.Name] = InQuint;
		[Enum.EasingStyle.Bounce.Name] = InBounce;
		[Enum.EasingStyle.Elastic.Name] = InElastic;
		[Enum.EasingStyle.Exponential.Name] = InExpo;
		[Enum.EasingStyle.Circular.Name] = InCirc;
		[Enum.EasingStyle.Cubic.Name] = InCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};

	[Enum.EasingDirection.Out.Name] = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = OutSine;
		[Enum.EasingStyle.Back.Name] = OutBack;
		[Enum.EasingStyle.Quad.Name] = OutQuad;
		[Enum.EasingStyle.Quart.Name] = OutQuart;
		[Enum.EasingStyle.Quint.Name] = OutQuint;
		[Enum.EasingStyle.Bounce.Name] = OutBounce;
		[Enum.EasingStyle.Elastic.Name] = OutElastic;
		[Enum.EasingStyle.Exponential.Name] = OutExpo;
		[Enum.EasingStyle.Circular.Name] = OutCirc;
		[Enum.EasingStyle.Cubic.Name] = OutCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};

	[Enum.EasingDirection.InOut.Name] = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = InOutSine;
		[Enum.EasingStyle.Back.Name] = InOutBack;
		[Enum.EasingStyle.Quad.Name] = InOutQuad;
		[Enum.EasingStyle.Quart.Name] = InOutQuart;
		[Enum.EasingStyle.Quint.Name] = InOutQuint;
		[Enum.EasingStyle.Bounce.Name] = InOutBounce;
		[Enum.EasingStyle.Elastic.Name] = InOutElastic;
		[Enum.EasingStyle.Exponential.Name] = InOutExpo;
		[Enum.EasingStyle.Circular.Name] = InOutCirc;
		[Enum.EasingStyle.Cubic.Name] = InOutCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};

	OutIn = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = OutInSine;
		[Enum.EasingStyle.Back.Name] = OutInBack;
		[Enum.EasingStyle.Quad.Name] = OutInQuad;
		[Enum.EasingStyle.Quart.Name] = OutInQuart;
		[Enum.EasingStyle.Quint.Name] = OutInQuint;
		[Enum.EasingStyle.Bounce.Name] = OutInBounce;
		[Enum.EasingStyle.Elastic.Name] = OutInElastic;
		[Enum.EasingStyle.Exponential.Name] = OutInExpo;
		[Enum.EasingStyle.Circular.Name] = OutInCirc;
		[Enum.EasingStyle.Cubic.Name] = OutInCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};
}
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX604B6FB1EF3A46819535BA9E142B000A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXED617444DC1D4B2F84267140EB46E368">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX712E335547BB4FFE87FE8ECE9171A2D4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBXA6FBE5AA8C344E3C89C80DD0C974736D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX98757A664383445384FADA0541068546">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX0FDED2BE2A3B4C83BD7D32C9AC502EFA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBXD368A910EA6548A89EA295D7A7541FAF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBXB8AB732287E14ABD96DF54C6490679D4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX4EB01197596E43408F13F0256F98C2D5">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBXC4B564B480214DFF8AE2262FB5B67E83">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX44E92E8D30EE4462BAF137572F2B0DAD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXCDBDE30BAFAA4160B5A99F5EDF0BDA8D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX75085FB8354F4EAA9E038E974F95230A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXDEB4283B5BBC4900A4745A91C57226E9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXFA5C374EFF3846259910DDEBC8263F8D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX471F1F48DC0448C4BE7C0D8FDCBEEFCD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX6D7DD19EBD8C410597E04A69EE81C618">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBX7FB1496598D84D7B84BC2222D8D4D749">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX6BDD431008204B728241CA0DB406E199">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBX5429066ED4D54D06B32F1618FB828D4B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXC662FE8587CD4EF8AF82D857E3673620">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Aero</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXDDF0223C1EAA4177B40B5C1FBDEB2FD6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Internal</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Script" referent="RBX64FA63D6B699463F9C0A4FE5CCA4670A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AeroServer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Aero Server
-- Stephen Leitnick
-- July 21, 2017



local AeroServer = {
	Services = {};
	Modules = {};
	Shared = {};
}

local mt = {__index = AeroServer}

local servicesFolder = game:GetService("ServerStorage").Aero.Services
local modulesFolder = game:GetService("ServerStorage").Aero.Modules
local sharedFolder = game:GetService("ReplicatedStorage").Aero.Shared

local remoteServices = Instance.new("Folder")
remoteServices.Name = "AeroRemoteServices"

local players = {}
local modulesAwaitingStart = {}

local SpawnNow = require(sharedFolder.Thread:Clone()).SpawnNow

local function PreventEventRegister()
	error("Cannot register event after Init method")
end

local function PreventFunctionRegister()
	error("Cannot register function after Init method")
end

local function PreventMethodCache()
	error("Cannot mark method as cachable after Init method")
end


function AeroServer:RegisterEvent(eventName)
	local event = self.Shared.Event.new()
	self._events[eventName] = event
	return event
end


function AeroServer:RegisterClientEvent(eventName)
	local event = Instance.new("RemoteEvent")
	event.Name = eventName
	event.Parent = self._remoteFolder
	self._clientEvents[eventName] = event
	return event
end


function AeroServer:Fire(eventName, ...)
	self._events[eventName]:Fire(...)
end


function AeroServer:FireEvent(eventName, ...)
	warn("FireEvent has been deprecated in favor of Fire")
	self:Fire(eventName, ...)
end


function AeroServer:FireClient(eventName, client, ...)
	self._clientEvents[eventName]:FireClient(client, ...)
end


function AeroServer:FireClientEvent(eventName, client, ...)
	warn("FireClientEvent has been deprecated in favor of FireClient")
	self:FireClient(eventName, client, ...)
end


function AeroServer:FireAllClients(eventName, ...)
	self._clientEvents[eventName]:FireAllClients(...)
end


function AeroServer:FireAllClientsEvent(eventName, ...)
	warn("FireAllClientsEvent has been deprecated in favor of FireAllClients")
	self:FireAllClients(eventName, ...)
end


function AeroServer:FireOtherClients(eventName, clientIgnore, ...)
	local event = self._clientEvents[eventName]
	for _,player in ipairs(players) do
		if (player ~= clientIgnore) then
			event:FireClient(player, ...)
		end
	end
end


function AeroServer:FireAllClientsEventExcept(eventName, client, ...)
	warn("FireAllClientsEventExcept has been deprecated in favor of FireOtherClients")
	self:FireOtherClients(eventName, client, ...)
end


function AeroServer:ConnectEvent(eventName, func)
	return self._events[eventName]:Connect(func)
end


function AeroServer:ConnectClientEvent(eventName, func)
	return self._clientEvents[eventName].OnServerEvent:Connect(func)
end


function AeroServer:WaitForEvent(eventName)
	return self._events[eventName]:Wait()
end


function AeroServer:WaitForClientEvent(eventName)
	return self._clientEvents[eventName]:Wait()
end


function AeroServer:RegisterClientFunction(funcName, func, cacheTTL)
	local remoteFunc = Instance.new("RemoteFunction")
	remoteFunc.Name = funcName
	remoteFunc.OnServerInvoke = function(...)
		return func(self.Client, ...)
	end
	if (cacheTTL ~= nil) then
		local cache = Instance.new("NumberValue")
		cache.Name = "Cache"
		cache.Value = cacheTTL
		cache.Parent = remoteFunc
	end
	remoteFunc.Parent = self._remoteFolder
	return remoteFunc
end


function AeroServer:WrapModule(tbl)
	assert(type(tbl) == "table", "Expected table for argument")
	tbl._events = {}
	setmetatable(tbl, mt)
	if (type(tbl.Init) == "function" and not tbl.__aeroPreventInit) then
		tbl:Init()
	end
	if (type(tbl.Start) == "function" and not tbl.__aeroPreventStart) then
		if (modulesAwaitingStart) then
			modulesAwaitingStart[#modulesAwaitingStart + 1] = tbl
		else
			SpawnNow(tbl.Start, tbl)
		end
	end
end


function AeroServer:CacheClientMethod(methodName, ttl)
	assert(self._clientCaches, "CacheClientMethod must be called within Init method")
	assert(type(methodName) == "string", "CacheClientMethod argument #1 must be a string")
	assert(self.Client and type(self.Client[methodName]) == "function", "CacheClientMethod argument #1 must be a client method")
	if (ttl == nil) then ttl = 0 end
	assert(type(ttl) == "number" and ttl >= 0, "CacheClientMethod argument #2 must be a number >= 0")
	self._clientCaches[methodName] = (ttl or 0)
end


-- Setup table to load modules on demand:
local function LazyLoadSetup(tbl, folder)
	setmetatable(tbl, {
		__index = function(t, i)
			local child = folder[i]
			if (child:IsA("ModuleScript")) then
				local obj = require(child)
				rawset(t, i, obj)
				if (type(obj) == "table") then
					-- Only wrap module if it's actually a table, and not a table disguised as a function:
					local objMetatable = getmetatable(obj)
					if (not (objMetatable and objMetatable.__call)) then
						AeroServer:WrapModule(obj)
					end
				end
				return obj
			elseif (child:IsA("Folder")) then
				local nestedTbl = {}
				rawset(t, i, nestedTbl)
				LazyLoadSetup(nestedTbl, child)
				return nestedTbl
			end
		end;
	})
end


-- Load service from module:
local function LoadService(module, servicesTbl, parentFolder)
	
	local remoteFolder = Instance.new("Folder")
	remoteFolder.Name = module.Name
	remoteFolder.Parent = parentFolder
	
	local service = require(module)
	servicesTbl[module.Name] = service
	
	if (type(service.Client) ~= "table") then
		service.Client = {}
	end
	service.Client.Server = service
	
	setmetatable(service, mt)
	
	service._events = {}
	service._clientEvents = {}
	service._clientCaches = {}
	service._remoteFolder = remoteFolder
	
end


local function InitService(service)
	
	-- Initialize:
	if (type(service.Init) == "function") then
		service:Init()
	end
	
	-- Client functions:
	for funcName,func in pairs(service.Client) do
		if (type(func) == "function") then
			service:RegisterClientFunction(funcName, func, service._clientCaches[funcName])
		end
	end

	-- Disallow registering events/functions after init:
	service.RegisterEvent = PreventEventRegister
	service.RegisterClientEvent = PreventEventRegister
	service.RegisterClientFunction = PreventFunctionRegister
	service.CacheClientMethod = PreventMethodCache
	
end


local function StartService(service)

	-- Start services on separate threads:
	if (type(service.Start) == "function") then
		SpawnNow(service.Start, service)
	end

end


local function Init()

	local function PlayerAdded(player)
		players[#players + 1] = player
	end

	local function PlayerRemoving(player)
		local nPlayers = #players
		for i = 1,nPlayers do
			if (players[i] == player) then
				players[i] = players[nPlayers]
				players[nPlayers] = nil
			end
		end
	end
	
	-- Load service modules:
	local function LoadAllServices(parent, servicesTbl, parentFolder)
		for _,child in ipairs(parent:GetChildren()) do
			if (child:IsA("ModuleScript")) then
				LoadService(child, servicesTbl, parentFolder)
			elseif (child:IsA("Folder")) then
				local tbl = {}
				local folder = Instance.new("Folder")
				folder.Name = child.Name
				folder.Parent = parentFolder
				servicesTbl[child.Name] = tbl
				LoadAllServices(child, tbl, folder)
			end
		end
	end
	
	-- Initialize services:
	local function InitAllServices(services)
		-- Collect all services:
		local serviceTables = {}
		local function CollectServices(_services)
			for _,service in pairs(_services) do
				if (getmetatable(service) == mt) then
					serviceTables[#serviceTables + 1] = service
				else
					CollectServices(service)
				end
			end
		end
		CollectServices(services)
		-- Sort services by optional __aeroOrder field:
		table.sort(serviceTables, function(a, b)
			local aOrder = (type(a.__aeroOrder) == "number" and a.__aeroOrder or math.huge)
			local bOrder = (type(b.__aeroOrder) == "number" and b.__aeroOrder or math.huge)
			return (aOrder < bOrder)
		end)
		-- Initialize services:
		for _,service in ipairs(serviceTables) do
			InitService(service)
		end
	end

	-- Remove unused folders:
	local function ScanRemoteFoldersForEmpty(parent)
		for _,child in ipairs(parent:GetChildren()) do
			if (child:IsA("Folder")) then
				local remoteFunction = child:FindFirstChildWhichIsA("RemoteFunction", true)
				local remoteEvent = child:FindFirstChildWhichIsA("RemoteEvent", true)
				if ((not remoteFunction) and (not remoteEvent)) then
					child:Destroy()
				else
					ScanRemoteFoldersForEmpty(child)
				end
			end
		end
	end
	
	-- Start services:
	local function StartAllServices(services)
		for _,service in pairs(services) do
			if (getmetatable(service) == mt) then
				StartService(service)
			else
				StartAllServices(service)
			end
		end
	end

	-- Start modules that were already loaded:
	local function StartLoadedModules()
		for _,tbl in pairs(modulesAwaitingStart) do
			SpawnNow(tbl.Start, tbl)
		end
		modulesAwaitingStart = nil
	end

	--------------------------------------------------------------------

	players = game:GetService("Players"):GetPlayers()
	game:GetService("Players").PlayerAdded:Connect(PlayerAdded)
	game:GetService("Players").PlayerRemoving:Connect(PlayerRemoving)
	
	-- Lazy-load server and shared modules:
	LazyLoadSetup(AeroServer.Modules, modulesFolder)
	LazyLoadSetup(AeroServer.Shared, sharedFolder)

	-- Load, init, and start services:
	LoadAllServices(servicesFolder, AeroServer.Services, remoteServices)
	InitAllServices(AeroServer.Services)
	ScanRemoteFoldersForEmpty(remoteServices)
	StartAllServices(AeroServer.Services)
	StartLoadedModules()
	
	-- Expose server framework to client and global scope:
	remoteServices.Parent = game:GetService("ReplicatedStorage").Aero
	_G.AeroServer = AeroServer
	_G.Aero = AeroServer
	
end


Init()
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBXCDD338B89BB94FF0B209EBBC5FF438E1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX860E709B9BB74C5DA3DA54D81DD1E605">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Aero</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX9487443D0AEC45AF836592C432595872">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Modules</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX5E9C9188FF9C4637B30D9E06ED3D4A44">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Data</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Data
-- Stephen Leitnick
-- November 20, 2018


--[[
	
	CONSTRUCTORS:
		data = Data.new(name, scope [, ordered])              [Creates or gets existing Data object for given name and scope]
		data = Data.ForPlayer(userId | player [, ordered])    [Creates or gets existing Data object for given player OR UserId]
		data = Data.ForServer([ordered])                      [Creates or gets existing Data object for the server]

	STATIC FIELDS:
		Data.IsUsingMockService        [Whether or not the MockDataStoreService is being utilized]
		Data.AutoSaveInterval          [How often all data auto-saves. Defaults to '60' seconds]
		Data.PlayerLeftSaveInterval    [How long to wait after a player leaves before saving all data. Defaults to '10' seconds]
		Data.SaveInStudio              [Defaults to 'false'; indicates if data should save when testing in Studio]

	STATIC METHODS:
		Data:OnClose(onCloseFunc)      [Guaranteed to be executed before all data is saved when server is closing]

	FIELDS:
		data.CanAutoSave        [Defaults to 'true']
		data.DestroyOnLeave     [Defaults to 'true'; if linked to a player, 'Destroy()' will automatically be invoked when the player leaves; see static field PlayerLeftSaveInterval]

	METHODS:
		Promise<Value>          data:Get(String key [, Any defaultValue])
		Promise<DataStorePage>  data:GetSorted(Boolean isAscendint, Int pageSize, Number minValue, Number maxValue)
		Promise<Void>           data:Set(String key, String value)
		Promise<Void>           data:Delete(String key)
		Promise<Value>          data:Increment(String key, Number incrementValue)
		Promise<Connection>     data:OnUpdate(String key, Function callback)
		Promise<Void>           data:Save(String key)
		Promise<Void>           data:SaveAll()
		Promise<Void>           data:Destroy([Boolean saveAll])
		Number                  data:GetRequestBudget(DataStoreRequestType requestType)
		Void                    data:MarkDirty(String key)
		
	EVENTS:
		data.Success         data.Success:Connect(String method, String key)
		data.Failed          data.Failed:Connect(String method, String key, String err)

	METHOD DESCRIPTIONS:
		Get
			Gets/loads the value from the key. The optional 'defaultValue' can be used
			if the retrieved value from the DataStore is nil. This method will only
			call the DataStore if it has not yet done so and gotten a non-nil value. If
			a call has already been made for the given key, the value will be cached
			and the cached value will be returned.

		GetSorted
			Calls the GetSortedAsync method on the OrderedDataStore connected to this
			data object. It will return a custom DataStorePage object described below:

			DataStorePage:
				Boolean         dataStorePage.IsFinished
				Promise<Void>   dataStorePage:AdvanceToNextPage()
				Promise<Table>  dataStorePage:GetCurrentPage()

		Set
			Sets the value to the given key in the local cache. This does NOT set the
			value in the DataStore. Call 'Save' or 'SaveAll' to explicitly save to the
			DataStore. Otherwise, the key will automatically save during the auto-save
			period, when the player leaves, or when the server shuts down.

			If you try to set a value to a key that has not yet been cached, it will
			first try to call the DataStore to ensure it is working. If DataStores
			are down, this call will fail, ensuring that you don't start overriding
			values during DataStore downtime.

		Delete
			This deletes the value from the cache AND the DataStore. This is the same
			as calling 'data:Set("key", nil)' but is preferred for its explicit naming.

		Increment
			This increments a value on a given key. If the current value doesn't exist,
			then it will assume a starting value of 0. This will fail if the increment
			or the existing value is not a number.

		OnUpdate
			This registers a function to listen for changes on a key at the DataStore
			level, NOT the cache level. Thus, using 'data:Set()' won't trigger a bound
			function on OnUpdate. In other words, this function can be used to tell
			when a key has been saved onto the DataStore.

		Save
			Saves a cached key to the DataStore. The key must currently have a cached
			value, otherwise this request will fail.

		SaveAll
			Saves all currently cached keys to the DataStore.

		Destroy
			Destroys the data object instance. If 'saveAll' is set to 'true', this will
			also call 'SaveAll' before removing any of the data.

		GetRequestBudget
			This is exactly the same as the DataStoreService's GetRequestBudget. Read
			the documentation on the Roblox Developer site:
			https://developer.roblox.com/api-reference/function/DataStoreService/GetRequestBudgetForRequestType

		MarkDirty
			Marks the key as dirty, which means that it will be forced to save the
			next time a save invocation occurs. This is necessary when making changes
			to tables.
	

	EXAMPLES:

		data = Data.ForPlayer(somePlayer)

		-- Using 'Await' to get money:
		local success, money = data:Get("money", 0):Await()
		if (success) then
			print("Money", money)
		else
			warn("Failed to get money", money)
		end

		-- Using 'Then' to get money:
		data:Get("money", 0):Then(function(money)
			print("Money", money)
		end, function(err)
			warn("Failed to get money", err)
		end)

		-- Setting money:
		data:Set("money", 25):Await()

		-- Saving:
		data:Save("money"):Then(function()
			print("Successfully saved money")
		end):Catch(function(err)
			warn("Failed to save money", err)
		end):Finally(function()
			-- Cleanup stuff
		end)


		-- OrderedDataStore example:
		data = Data.ForPlayer(somePlayer, true)

		data:GetSorted(true, 10, 0, 1000):Then(function(pages)
			return pages:GetCurrentPage()
		end):Then(function(page)
			for k,v in pairs(page) do
				print(k, v)
			end
		end)



	For in-depth info on DataStores:

		https://devforum.roblox.com/t/details-on-datastoreservice-for-advanced-developers/175804

--]]



local Data = {}
Data.__index = Data
Data._onCloseHandlers = {}

-- Static fields; customize as needed:
Data.AutoSaveInterval = 60
Data.PlayerLeftSaveInterval = 10
Data.SaveInStudio = false
Data.Log = false

-- Constants based on internal Roblox DataStore; DO NOT CHANGE:
local NAME_MAX_LEN = 50
local SCOPE_MAX_LEN = 50
local KEY_MAX_LEN = 49

local KEY_MAX_LEN_ERR = "Key must be a string less or equal to " .. KEY_MAX_LEN .. " characters"
local PLAYER_DATA_NAME = "PlayerData"

local dataStoreService = game:GetService("DataStoreService")
Data.IsUsingMockService = false

local dataPool = {}
local assert = assert
local tableUtil
local Promise


local function Log(...)
	if (not Data.Log) then return end
	print("Data ->", ...)
end


local function HeartbeatSpawn(callback, ...)
	local hb
	local args = table.pack(...)
	hb = game:GetService("RunService").Heartbeat:Connect(function()
		hb:Disconnect()
		callback(table.unpack(args, 1, args.n))
	end)
end


-- Check if key matches DataStore criteria:
local function CheckKey(key)
	return (type(key) == "string" and #key <= KEY_MAX_LEN)
end

-- Retrieve cached DataStore from name and scope:
local function GetDataFromNameAndScope(name, scope)
	local ds = dataStoreService:GetDataStore(name, scope)
	return dataPool[ds]
end


---------------------------------------------------------------------------------------------------------------------------
-- DataStorePages wrapper for promises:

local DataStorePages = {}
DataStorePages.__index = DataStorePages
function DataStorePages.new(dsp)
	return setmetatable({
		DSP = dsp;
		IsFinished = dsp.IsFinished;
	}, DataStorePages)
end

function DataStorePages:AdvanceToNextPage()
	return Promise.Async(function(resolve, reject)
		local success, err = pcall(self.DSP.AdvanceToNextPageAsync, self.DSP)
		self.IsFinished = self.DSP.IsFinished
		if (success) then resolve() else reject(err) end
	end)
end

function DataStorePages:GetCurrentPage()
	return Promise.Async(function(resolve, reject)
		local success, page = pcall(self.DSP.GetCurrentPage, self.DSP)
		if (success) then resolve(page) else reject(page) end
	end)
end
---------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------
-- CONSTRUCTORS:


function Data.new(name, scope, ordered)

	-- Check arguments:
	assert(type(name) == "string", "Argument #1 (name) must be a string")
	assert(type(scope) == "string", "Argument #2 (scope) must be a string")
	assert(#name <= NAME_MAX_LEN, "Argument #1 (name) must be less or equal to " .. NAME_MAX_LEN .. " characters")
	assert(#scope <= SCOPE_MAX_LEN, "Argument #1 (scope) must be less or equal to " .. SCOPE_MAX_LEN .. " characters")
	assert(type(ordered) == "boolean" or ordered == nil, "Argument #3 (ordered) must be a boolean or nil")

	ordered = (not not ordered)

	-- Get cached 'data' object if available:
	local ds = (ordered and dataStoreService:GetOrderedDataStore(name, scope) or dataStoreService:GetDataStore(name, scope))
	local self = dataPool[ds]
	if (self and not self._destroyed) then return self end

	-- Create new 'data' object:
	self = setmetatable({
		Name = name;
		Scope = scope;
		CanAutoSave = true;
		DestroyOnLeave = true;
		_ds = ds;
		_cache = {};
		_dirty = {};
		_ordered = ordered;
		_destroyed = false;
		_destroying = false;
	}, Data)
	
	-- Data events:
	self.Success = self.Shared.Event.new()
	self.Failed = self.Shared.Event.new()

	dataPool[ds] = self

	Log("Created new Data object:", tostring(self))

	return self

end


function Data.ForPlayer(userId, ordered)
	if (typeof(userId) == "Instance") then
		-- Capture UserId from the player object:
		assert(userId:IsA("Player"), "Expected Player; got " .. userId.ClassName)
		userId = userId.UserId
	else
		assert(type(userId) == "number" and userId >= 0 and math.floor(userId) == userId, "Expected integer >= 0")
	end
	local scope = tostring(userId)
	local data = Data.new(PLAYER_DATA_NAME, scope, ordered)
	return data
end


function Data.ForServer(ordered)
	return Data.new("global", "global", ordered)
end


---------------------------------------------------------------------------------------------------------------------------
-- PRIVATE METHODS:


-- Load a given key from the DataStore:
function Data:_load(key)
	Log("Loading " .. key .. "...")
	return Promise.Async(function(resolve, reject)
		-- Call GetAsync and cache the results:
		local success, value = pcall(self._ds.GetAsync, self._ds, key)
		if (success) then
			Log("Succesfully loaded key " .. key .. ":", value)
			self._cache[key] = value
			self._dirty[key] = false
			self.Success:Fire("GetAsync", key)
			resolve(value)
		else
			Log("Failede to load key " .. key)
			self.Failed:Fire("GetAsync", key, value)
			reject(value)
		end
	end)
end


-- Get the cached value from the key, or load it from the DataStore if not yet cached:
function Data:_loadIfNotCached(key)
	if (self:_cacheExists(key)) then
		return Promise.Resolve(self:_getCache(key))
	end
	return self:_load(key)
end


-- Save the key/value to the DataStore:
function Data:_save(key, value)
	Log("Saving " .. key .. "...")
	if (self._dirty[key] == false) then
		-- If not dirty, the given key does not need to be saved:
		Log("No save necessary; " .. key .. " not marked as dirty")
		return Promise.Resolve()
	end
	return Promise.Async(function(resolve, reject)
		-- Call SetAsync and mark key as no longer dirty:
		local valBeforeSave = self:_getCache(key)
		local success, err = pcall(self._ds.SetAsync, self._ds, key, value)
		if (success) then
			if (self:_getCache(key) == valBeforeSave) then
				self._dirty[key] = false
			end
			self.Success:Fire("SetAsync", key)
			Log("Successfully saved " .. key .. ":", value)
			resolve()
		else
			Log("Failed to save " .. key)
			self.Failed:Fire("SetAsync", key, err)
			reject(err)
		end
	end)
end


function Data:_delete(key)
	Log("Deleting " .. key .. "...")
	return Promise.Async(function(resolve, reject)
		-- Call RemoveAsync and remove value from cache:
		local success, err = pcall(self._ds.RemoveAsync, self._ds, key)
		if (success) then
			Log("Successfully deleted key " .. key)
			self:_clearCache(key)
			self.Success:Fire("RemoveAsync", key)
			resolve()
		else
			Log("Failed to delete key " .. key)
			self.Failed:Fire("RemoveAsync", key, err)
			reject(err)
		end
	end)
end


function Data:_update(key, transformFunc)
	Log("Updating " .. key .. "...")
	return Promise.Async(function(resolve, reject)
		-- Call UpdateAsync and update cache with returned value:
		local success, value = pcall(self._ds.UpdateAsync, self._ds, key, transformFunc)
		if (success) then
			Log("Successfully updated key " .. key)
			self:_setCache(key, value, true)
			self.Success:Fire("UpdateAsync", key)
			resolve(value)
		else
			Log("Failed to update key " .. key)
			self.Failed:Fire("UpdateAsync", key, value)
			reject(value)
		end
	end)
end


function Data:_getSorted(isAscending, pageSize, minValue, maxValue)
	return Promise.Async(function(resolve, reject)
		-- Call GetSortedAsync and return the custom DataStorePages object:
		local success, dsp = pcall(self._ds.GetSortedAsync, self._ds, isAscending, pageSize, minValue, maxValue)
		if (success) then
			resolve(DataStorePages.new(dsp))
		else
			reject(dsp)
		end
	end)
end


-- Retrieve a cached value for the given key:
function Data:_getCache(key)
	return self._cache[key]
end


-- Set an item in the cache and mark clean or dirty:
function Data:_setCache(key, value, isClean)
	if (self._cache[key] ~= value) then
		self._cache[key] = value
		self._dirty[key] = (not isClean)
	end
end


-- Delete an item from the cache:
function Data:_clearCache(key)
	self._cache[key] = nil
	self._dirty[key] = nil
end


-- Check if a key has a value in the cache:
function Data:_cacheExists(key)
	return (self._cache[key] ~= nil)
end


-- Get the number of keys within the cache:
function Data:_countKeysInCache()
	local keyCount = 0
	for _ in pairs(self._cache) do
		keyCount = (keyCount + 1)
	end
	return keyCount
end


---------------------------------------------------------------------------------------------------------------------------
-- PUBLIC METHODS:


function Data:GetRequestBudget(reqType)
	-- See:
		-- https://developer.roblox.com/api-reference/function/DataStoreService/GetRequestBudgetForRequestType
		-- https://developer.roblox.com/api-reference/enum/DataStoreRequestType
		-- https://developer.roblox.com/articles/Datastore-Errors
	return dataStoreService:GetRequestBudgetForRequestType(reqType)
end


function Data:Get(key, defaultVal)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	if (self:_cacheExists(key)) then
		-- Return the cached value:
		return Promise.Resolve(self:_getCache(key))
	end
	-- Load and return value since it was not in the cache:
	return self:_load(key):Then(function(value)
		if (value == nil and defaultVal ~= nil) then
			value = defaultVal
			if (typeof(defaultVal) == "table") then
				value = tableUtil.Copy(defaultVal)
			end
			return self:Set(key, value):Then(function()
				return value
			end)
		else
			return value
		end
	end)
end


function Data:GetSorted(isAscending, pageSize, minValue, maxValue)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not self._ordered) then
		return Promise.Reject("GetSorted can only be invoked on an ordered data object")
	end
	return self:_getSorted(isAscending, pageSize, minValue, maxValue)
end


function Data:Set(key, value)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	return self:_loadIfNotCached(key):Then(function()
		if (value == nil) then
			return self:_delete(key)
		else
			self:_setCache(key, value)
		end
	end)
end


function Data:Increment(key, increment)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (type(increment) ~= "number") then
		return Promise.Reject("Increment must be a number")
	end
	-- Get the current value, increment it, then set the new value:
	return self:Get(key, 0):Then(function(value)
		if (type(value) ~= "number") then
			error("Cannot increment a non-number value")
			return
		end
		value = (value + increment)
		return self:Set(key, value):Then(function()
			return value
		end)
	end)
end


function Data:Delete(key)
	return self:Set(key, nil)
end


function Data:OnUpdate(key, callback)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	if (type(callback) ~= "function") then
		return Promise.Reject("Callback must be a function")
	end
	return Promise.Async(function(resolve, reject)
		local success, err = pcall(self._ds.OnUpdate, self._ds, key, callback)
		if (success) then
			self.Success:Fire("OnUpdate", key)
			resolve()
		else
			self.Failed:Fire("OnUpdate", key, err)
			reject(err)
		end
	end)
end


function Data:Save(key)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	local cachedVal = self:_getCache(key)
	if (cachedVal == nil) then
		return Promise.Reject("Cannot save key that has not already been loaded via Data:Get(key)")
	end
	return self:_save(key, cachedVal)
end


function Data:SaveAll()
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	-- Collect all 'Save' promises and return them all in a single promise:
	local promises = {}
	for key in pairs(self._cache) do
		promises[#promises + 1] = self:Save(key)
	end
	return Promise.All(promises)
end


function Data:Update(key, transformFunc)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	if (type(transformFunc) ~= "function") then
		return Promise.Reject("TransformFunction must be a function")
	end
	return self:_update(key, transformFunc)
end


function Data:MarkDirty(key)
	self._dirty[key] = true
end


function Data:Destroy(save)
	Log("Destroying data object:", tostring(self))
	if (self._destroyed or self._destroying) then
		return Promise.Reject("Data already destroyed")
	end
	self._destroying = true
	local savePromise
	if (save) then
		savePromise = self:SaveAll(false, nil)
	else
		savePromise = Promise.Resolve()
	end
	return savePromise:Then(function()
		-- Clear and destroy objects:
		Log("Data successfully destroyed")
		self._destroyed = true
		self._cache = {}
		self._dirty = {}
		self.Failed:Destroy()
		self.Success:Destroy()
		dataPool[self._ds] = nil
	end):Catch(function(err)
		-- Failed to destroy, thus remark as not destroyed & rethrow error:
		Log("   Saving failed")
		self._destroying = false
		error(err)
	end)
end


---------------------------------------------------------------------------------------------------------------------------


function Data:OnClose(handler)
	assert(type(handler) == "function", "OnClose handler must be a function")
	for _,h in ipairs(self._onCloseHandlers) do
		if (h == handler) then
			error("Handler already binded")
		end
	end
	table.insert(self._onCloseHandlers, handler)
end


function Data:Start()

	local gameClosing = false
	local autoSaving = false

	if (game.GameId == 0) then
		Data.IsUsingMockService = true
	elseif (game:GetService("RunService"):IsStudio()) then
		if (not Data.SaveInStudio) then
			Data.IsUsingMockService = true
		else
			-- Verify status of the DataStoreService on startup:
			local success, err = pcall(function()
				dataStoreService:GetDataStore("__aero"):UpdateAsync("dss_api_check", function(v) return v == nil and true or v end)
			end)
			if (not success) then
				-- Error codes: https://developer.roblox.com/articles/Datastore-Errors
				local errCode = tonumber(err:match("^%d+"))
				if (errCode == 502 or errCode == 403) then
					Data.IsUsingMockService = true
				elseif (errCode == 304) then
					error("DataStoreService API check failed on UpdateAsync (request queue full)")
				else
					error("DataStoreService API error " .. errCode or "[Unknown Status]" .. ": " .. err)
				end
			end
		end
	end
	
	local function FireBoundToCloseCallbacks()
		local numBinded = #self._onCloseHandlers
		if (numBinded == 0) then return end
		local bindable = Instance.new("BindableEvent")
		local numCompleted = 0
		for _,func in ipairs(self._onCloseHandlers) do
			HeartbeatSpawn(function()
				local success, err = pcall(func)
				if (not success) then
					warn("Data BindToClose function failed: " .. tostring(err))
				end
				numCompleted = (numCompleted + 1)
				if (numCompleted == numBinded) then
					bindable:Fire()
				end
			end)
		end
		bindable.Event:Wait()
		bindable:Destroy()
	end
	
	local function AutoSaveAllData()
		if (autoSaving) then return end
		autoSaving = true
		local promises = {}
		for _,data in pairs(dataPool) do
			if (data.CanAutoSave) then
				--local budget = dataStoreService:GetRequestBudgetForRequestType(Enum.DataStoreRequestType.SetIncrementAsync)
				--local keys = data:_countKeysInCache()
				local saveAllPromise = data:SaveAll()
				if (not gameClosing) then
					saveAllPromise:Await()
				else
					promises[#promises + 1] = saveAllPromise
				end
			end
		end
		if (#promises == 0) then
			autoSaving = false
		else
			Promise.All(promises):Await()
			autoSaving = false
		end
	end

	if (self.IsUsingMockService) then
		-- Use mock DataStoreService:
		dataStoreService = require(script.MockDataStoreService)
	else
		-- Auto-save all data before server closes:
		game:BindToClose(function()
			gameClosing = true
			FireBoundToCloseCallbacks()
			AutoSaveAllData()
		end)
	end

	-- Destroy player data when player leaves:
	game:GetService("Players").PlayerRemoving:Connect(function(player)
		local data = GetDataFromNameAndScope(PLAYER_DATA_NAME, tostring(player.UserId))
		if (not data) then return end
		wait(self.PlayerLeftSaveInterval)
		if (gameClosing or not data.DestroyOnLeave) then return end
		data:Destroy(true)
	end)

	-- Auto-save cycle:
	HeartbeatSpawn(function()
		while (true) do
			wait(self.AutoSaveInterval)
			if (gameClosing) then break end
			AutoSaveAllData()
		end
	end)

end


function Data:Init()
	Promise = self.Shared.Promise
	tableUtil = self.Shared.TableUtil
end


function Data:__tostring()
	return ("Data (Name=%s, Scope=%s, Ordered=%s)"):format(self.Name, self.Scope, self._ordered and "Yes" or "No")
end


return Data]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE4D3C3B46A954345B8275A16391C6EB8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MockDataStoreService</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[-- Mock DataStoreService
-- Stephen Leitnick
-- August 20, 2014


--[[
	
	USAGE EXAMPLE:
	
		--------
		local dataStoreService = game:GetService("DataStoreService")
		
		-- Mock service if the game is offline:
		if (game.PlaceId == 0) then
			dataStoreService = require(game.ServerStorage.MockDataStoreService)
		end
		
		-- dataStoreService will act exactly like the real one
		--------
	
	The mocked data store service should function exactly like the
	real service. What the mocked service does is "override" the
	core methods, such as GetAsync. If you try to index a property
	that hasn't been overridden (such as dataStoreService.Name), it
	will reference the actual property in the real dataStoreService.
	
	NOTE:
		This has been created based off of the DataStoreService on
		August 20, 2014. If a change has been made to the service,
		this mocked version will not reflect the changes.
	
--]]



local DataStoreService = {}
local API = {}
local MT = {}


-----------------------------------------------------------------------------------------------------------

local realDataStoreService = game:GetService("DataStoreService")
local allStores = {}

if (game:GetService("Players").LocalPlayer) then
	warn("Mocked DataStoreService is functioning on the client: The real DataStoreService will not work on the client")
end


-----------------------------------------------------------------------------------------------------------
-- API:

function API:GetDataStore(name, scope)
	assert(type(name) == "string", "DataStore name must be a string; got" .. type(name))
	assert(type(scope) == "string" or scope == nil, "DataStore scope must be a string; got" .. type(scope))
	scope = (scope or "global")
	if (allStores[scope] and allStores[scope][name]) then
		return allStores[scope][name]
	end
	local data = {}
	local d = {}
	local updateListeners = {}
	function d.SetAsync(_s, k, v)
		assert(v ~= nil, "Value cannot be nil")
		data[k] = v
		if (updateListeners[k]) then
			for _,f in ipairs(updateListeners[k]) do
				spawn(function() f(v) end)
			end
		end
	end
	function d.UpdateAsync(_s, k, func)
		local v = func(data[k])
		assert(v ~= nil, "Value cannot be nil")
		data[k] = v
		if (updateListeners[k]) then
			for _,f in ipairs(updateListeners[k]) do
				spawn(function() f(v) end)
			end
		end
	end
	function d.GetAsync(_s, k)
		return data[k]
	end
	function d.RemoveAsync(_s, k)
		data[k] = nil
		if (updateListeners[k]) then
			for _,f in ipairs(updateListeners[k]) do
				spawn(function() f(nil) end)
			end
		end
	end
	function d.IncrementAsync(_s, k, delta)
		if (delta == nil) then delta = 1 end
		assert(type(delta) == "number", "Can only increment numbers")
		_s:UpdateAsync(k, function(num)
			if (num == nil) then
				return num
			end
			assert(type(num) == "number", "Can only increment numbers")
			return (num + delta)
		end)
	end
	function d.OnUpdate(_s, k, onUpdateFunc)
		assert(type(onUpdateFunc) == "function", "Update function argument must be a function")
		if (not updateListeners[k]) then
			updateListeners[k] = {onUpdateFunc}
		else
			table.insert(updateListeners[k], onUpdateFunc)
		end
	end
	if (not allStores[scope]) then
		allStores[scope] = {}
	end
	allStores[scope][name] = d
	return d
end


function API:GetGlobalDataStore()
	return self:GetDataStore("global", "global")
end


function API:GetOrderedDataStore(name, scope)
	local dataStore = self:GetDataStore(name, scope)
	local allData = {}
	local d = {}
	function d.GetAsync(_s, k)
		return dataStore:GetAsync(k)
	end
	function d.SetAsync(_s, k, v)
		assert(type(v) == "number", "Value must be a number")
		dataStore:SetAsync(k, v)
		allData[k] = v
	end
	function d.UpdateAsync(_s, k, func)
		dataStore:UpdateAsync(k, function(oldValue)
			local v = func(oldValue)
			assert(type(v) == "number", "Value must be a number")
			allData[k] = v
			return v
		end)
	end
	function d.IncrementAsync(_s, k, delta)
		dataStore:IncrementAsync(k, delta)
		allData[k] = ((allData[k] or 0) + delta)
	end
	function d.RemoveAsync(_s, k)
		dataStore:RemoveAsync(k)
		allData[k] = nil
	end
	function d.GetSortedAsync(_s, isAscending, pageSize, minValue, maxValue)
		assert(type(pageSize) == "number" and math.floor(pageSize) > 0, "PageSize must be an integer and greater than 0")
		assert(minValue == nil or type(minValue) == "number", "MinValue must be a number")
		assert(maxValue == nil or type(maxValue) == "number", "MaxValue must be a number")
		if (minValue and maxValue) then
			assert(minValue <= maxValue, "MinValue must be less or equal to MaxValue")
		end
		local data = {}
		for k,v in pairs(allData) do
			local pass = ((not minValue or v >= minValue) and (not maxValue or v <= maxValue))
			if (pass) then
				table.insert(data, {key = k, value = v})
			end
		end
		table.sort(data,
			(isAscending and
				function(a, b) return (a.value < b.value) end
			or
				function(a, b) return (b.value < a.value) end
			)
		)
		pageSize = math.floor(pageSize)
		local pages = {IsFinished = false}
		for i,v in pairs(data) do
			local pageNum = math.ceil(i / pageSize)
			local page = pages[pageNum]
			if (not page) then
				page = {}
				pages[pageNum] = page
			end
			local index = (((i - 1) % pageSize) + 1)
			page[index] = v
		end
		do
			local currentPage = 1
			function pages.GetCurrentPage(p)
				return p[currentPage]
			end
			function pages.AdvanceToNextPageAsync(p)
				local numPages = #pages
				if (currentPage < numPages) then
					currentPage = (currentPage + 1)
				end
				p.IsFinished = (currentPage >= numPages)
			end
		end
		return pages
	end
	return d
end


function API:GetRequestBudgetForRequestType(requestType)
	return realDataStoreService:GetRequestBudgetForRequestType(requestType)
end


-----------------------------------------------------------------------------------------------------------
-- Metatable:

MT.__metatable = true
MT.__index = function(_tbl, index)
	return (API[index] or realDataStoreService[index])
end
MT.__newindex = function()
	error("Cannot edit MockDataStoreService")
end
setmetatable(DataStoreService, MT)

-----------------------------------------------------------------------------------------------------------

return DataStoreService]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX54014498305445AFA51E5EA2FD15B40D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Services</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXFEAD4959736A4E46A1E81D814EF4FA65">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StoreService</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Store Service
-- Stephen Leitnick
-- December 1, 2015

-- Updated: December 31, 2016
-- Updated: March 2, 2017
-- Updated: December 29, 2019

--[[
	
	Server:
		
		StoreService:HasPurchased(player, productId)
		StoreService:OwnsGamePass(player, gamePassId)
		StoreService:GetNumberPurchased(player, productId)
		
		StoreService.PromptPurchaseFinished(player, receiptInfo)
	
	
	Client:
		
		StoreService:HasPurchased(productId)
		StoreService:OwnsGamePass(gamePassId)
		StoreService:GetNumberPurchased(productId)
	
		StoreService.PromptPurchaseFinished(receiptInfo)
	
--]]



local StoreService = {Client = {}}

local PRODUCT_PURCHASES_KEY = "ProductPurchases"
local PROMPT_PURCHASE_FINISHED_EVENT = "PromptPurchaseFinished"

local marketplaceService = game:GetService("MarketplaceService")
local dataStoreScope = "PlayerReceipts"

local Data


local function IncrementPurchase(player, productId)
	productId = tostring(productId)
	local playerData = Data.ForPlayer(player)
	return playerData:Get(PRODUCT_PURCHASES_KEY, {}):Then(function(productPurchases)
		local n = productPurchases[productId]
		productPurchases[productId] = (n and (n + 1) or 1)
		playerData:MarkDirty(PRODUCT_PURCHASES_KEY)
		return playerData:Save(PRODUCT_PURCHASES_KEY)
	end)
end


local function ProcessReceipt(receiptInfo)
	
	--[[
		ReceiptInfo:
			PlayerId               [Number]
			PlaceIdWherePurchased  [Number]
			PurchaseId             [String]
			ProductId              [Number]
			CurrencyType           [CurrencyType Enum]
			CurrencySpent          [Number]
	--]]
	
	local player = game:GetService("Players"):GetPlayerByUserId(receiptInfo.PlayerId)
	
	local dataStoreName = tostring(receiptInfo.PlayerId)
	local key = tostring(receiptInfo.PurchaseId)

	local notProcessed = Enum.ProductPurchaseDecision.NotProcessedYet
	
	-- Check if unique purchase was already completed:
	local data = Data.new(dataStoreName, dataStoreScope)
	local alreadyPurchasedSuccess, alreadyPurchased = data:Get(key):Await()
	if (not alreadyPurchasedSuccess) then return notProcessed end

	if (not alreadyPurchased) then
		-- Mark as purchased and save immediately:
		local success = data:Set(key, true):Then(function() return data:Save(key) end):Await()
		if (not success) then return notProcessed end
	end
	
	if (player) then
		local incSuccess = IncrementPurchase(player, receiptInfo.ProductId):Await()
		if (not incSuccess) then return notProcessed end
		StoreService:FireEvent(PROMPT_PURCHASE_FINISHED_EVENT, player, receiptInfo)
		StoreService:FireClientEvent(PROMPT_PURCHASE_FINISHED_EVENT, player, receiptInfo)
	end
	
	return Enum.ProductPurchaseDecision.PurchaseGranted
	
end


function StoreService:HasPurchased(player, productId)
	local success, productPurchases = Data.ForPlayer(player):Get(PRODUCT_PURCHASES_KEY, {}):Await()
	return (success and productPurchases[tostring(productId)] ~= nil)
end


function StoreService:OwnsGamePass(player, gamePassId)
	local success, owns = pcall(marketplaceService.UserOwnsGamePassAsync, marketplaceService, player.UserId, gamePassId)
	return (success and owns or false)
end


-- Get the number of productId's purchased:
function StoreService:GetNumberPurchased(player, productId)
	local n = 0
	local success, productPurchases = Data.ForPlayer(player):Get(PRODUCT_PURCHASES_KEY, {}):Await()
	if (success) then
		n = (productPurchases[tostring(productId)] or 0)
	end
	return n
end


-- Get the number of productId's purchased:
function StoreService.Client:GetNumberPurchased(player, productId)
	return self.Server:GetNumberPurchased(player, productId)
end


function StoreService.Client:OwnsGamePass(player, gamePassId)
	return self.Server:OwnsGamePass(player, gamePassId)
end


-- Whether or not the productId has been purchased before:
function StoreService.Client:HasPurchased(player, productId)
	return self.Server:HasPurchased(player, productId)
end


function StoreService:Start()
	marketplaceService.ProcessReceipt = ProcessReceipt
end


function StoreService:Init()
	Data = self.Modules.Data
	self:RegisterEvent(PROMPT_PURCHASE_FINISHED_EVENT)
	self:RegisterClientEvent(PROMPT_PURCHASE_FINISHED_EVENT)
end


return StoreService]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX8042CAF52CB84CD6AB6459AEE4DA4AA3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX95ED7985C0B446C78338A37FD348F1C0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Aero</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX2C006E4C2CF5495CAC03E16D57B799EC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Shared</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC70FA344147F492E9A8EE99CB050D8F8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Base64</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--- Base64
-- Encodes and decodes values to and from Base64
-- @author antifragileer <https://www.roblox.com/users/443282130/profile>
-- @see Developed for the Aero Game Framework <https://github.com/Sleitnick/AeroGameFramework>
-- @see Adapted from https://github.com/toastdriven/lua-base64 for the Roblox game.
-- @see Re-adapted from https://gist.github.com/howmanysmall/016a35f0debcfb81f14e6bee03d450de and https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2.
-- @license BSD
-- July 15, 2018

--[[
	
	local base64 = Base64.new()
	
	Example:
	
	local myEncodedWord = base64:Encode("Hello")
	
	print(myEncodedWord)
	
	-- outputs: SGVsbG8=
	
	print(base64:Decode(myEncodedWord))
	
	-- outputs: Hello

--]]

local Alphabet = {}
local Indexes = {}

for Index = 65, 90 do table.insert(Alphabet, Index) end -- A-Z
for Index = 97, 122 do table.insert(Alphabet, Index) end -- a-z
for Index = 48, 57 do table.insert(Alphabet, Index) end -- 0-9

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {
	ClassName = "Base64";
	__tostring = function(self) return self.ClassName end;
}

Base64.__index = Base64

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

function Base64.new()
	return setmetatable({}, Base64)
end

--[[**
	Encodes a string in Base64.
	@param [string] Input The input string to encode.
	@returns [string] The string encoded in Base64.
**--]]
function Base64:Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Output[Length + 1] = Alphabet[A + 1]
		Output[Length + 2] = Alphabet[B + 1]
		Output[Length + 3] = C2 and Alphabet[C + 1] or 61
		Output[Length + 4] = C3 and Alphabet[D + 1] or 61
		Length = Length + 4
	end

	local NewOutput = {}
	local NewLength = 0

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		NewOutput[NewLength] = string.char(table.unpack(Output, Index, math.min(Index + 4096 - 1, Length)))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [string] Input The input string to decode.
	@returns [string] The newly decoded string.
**--]]
function Base64:Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A
		if C3 ~= 61 then Length = Length + 1 Output[Length] = B end
		if C4 ~= 61 then Length = Length + 1 Output[Length] = C end
	end

	local NewOutput = {}
	local NewLength = 0

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		NewOutput[NewLength] = string.char(table.unpack(Output, Index, math.min(Index + 4096 - 1, Length)))
	end

	return table.concat(NewOutput)
end

return Base64
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX170C3A199BFA472C8BF2913DD5C1AD79">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Date</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Date
-- Stephen Leitnick
-- September 12, 2017

--[=[

	Represents a date at a specific time. On the server, this will
	return UTC time. On the client, this will return local time.
	Note that the server-side in Play-Solo testing will also return
	local time.

	You can optionally force UTC within the Date.new constructor.


	REQUIRE:

		local Date = require(thisModule)

	
	CONSTRUCTORS:

		local date = Date.new([seconds [, useUtc]])
		local date = Date.fromJSON(jsonString)


	METHODS:

		date:ToJSON()
		date:ToSeconds()
		date:GetTimezoneHourOffset()
		date:Format(strFormat)
		date:ToUTC()
		date:ToLocal()
		date:ToISOString()
		date:ToDateString()
		date:ToTimeString()
		date:ToString()


	PROPERTIES:

		date.Hour
		date.Minute
		date.Weekday
		date.Day
		date.Month
		date.Year
		date.Second
		date.Millisecond
		date.Yearday
		date.IsDST


	NOTE ON SAVING:

		You should use 'date:ToSeconds()' for saving. It can
		represent the date in the smallest format. While using
		'date:ToJSON()' will work too, it has a higher data
		footprint. Example:

		SAVE:

			local date = Date.new()
			dataStore:SetAsync("myDate", date:ToSeconds())

		LOAD:

			local myDateSeconds = dataStore:GetAsync("myDate")
			local date = Date.new(myDateSeconds)

	

--]=]



local Date = {}
Date.__index = Date


local useUTC = game:GetService("RunService"):IsServer()


local WEEKDAYS = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
local WEEKDAYS_SHORT = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}

local MONTHS = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
local MONTHS_SHORT = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}


-- Single-level table copy:
local function CopyTable(t)
	local tCopy = {}
	for k,v in pairs(t) do
		tCopy[k] = v
	end
	return tCopy
end


function Date.new(seconds, useUtcOverride)

	if (seconds ~= nil) then
		assert(type(seconds) == "number", "'seconds' argument #1 must be a number")
	else
		seconds = tick()
	end

	local utc = useUTC
	if (useUtcOverride ~= nil) then
		utc = useUtcOverride
	end

	local d = os.date(utc and "!*t" or "*t", seconds)

	local self = setmetatable({
		Hour = d.hour;
		Minute = d.min;
		Weekday = d.wday;
		Day = d.day;
		Month = d.month;
		Year = d.year;
		Second = d.sec;
		Millisecond = math.floor((seconds % 1) * 1000);
		Yearday = d.yday;
		IsDST = d.isdst;
		_d = d;
		_s = seconds;
	}, Date)

	return self

end


function Date.fromJSON(jsonStr)
	assert(type(jsonStr) == "string", "'jsonStr' argument #1 must be a string")
	local success, data = pcall(function()
		return game:GetService("HttpService"):JSONDecode(jsonStr)
	end)
	if (not success) then
		error("Failed to decode JSON string: " .. tostring(data))
	end
	local seconds
	if (data._s) then
		seconds = data._s
	else
		seconds = os.time(data)
	end
	return Date.new(seconds)
end


function Date:ToJSON()
	local data = CopyTable(self._d)
	data._s = self._s
end


function Date:ToSeconds()
	return self._s
end


function Date:GetTimezoneHourOffset()
	local dUTC = os.date("!*t", self._s)
	return (self._d.hour - dUTC.hour)
end


function Date:ToISOString()
	local utc = self:ToUTC()
	local d = utc._d
	return ("%.2i-%.2i-%.2iT%.2i:%.2i:%.2i.%.3i"):format(
		d.year,
		d.month,
		d.day,
		d.hour,
		d.min,
		d.sec,
		math.floor((utc._s % 1) * 1000)
	)
end


function Date:ToDateString()
	local d = self._d
	return ("%s %s %i %i"):format(
		WEEKDAYS_SHORT[d.wday],
		MONTHS_SHORT[d.month],
		d.day,
		d.year
	)
end


function Date:ToTimeString()
	local d = self._d
	return ("%.2i:%.2i:%.2i"):format(
		d.hour,
		d.min,
		d.sec
	)
end


function Date:ToString()
	return (self:ToDateString() .. " " .. self:ToTimeString())
end


function Date:ToUTC()
	return Date.new(self._s, true)
end


function Date:ToLocal()
	return Date.new(self._s, false)
end


-- See GNU date commands:
-- https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/
function Date:Format(str)
	local d = self._d
	local h12 = d.hour
	if (h12 > 12) then
		h12 = h12 - 12
	end
	if (h12 == 0) then
		h12 = 0
	end
	str = str
		:gsub("%%a", WEEKDAYS_SHORT[d.wday])
		:gsub("%%A", WEEKDAYS[d.wday])
		:gsub("%%b", MONTHS_SHORT[d.month])
		:gsub("%%B", MONTHS[d.month])
		:gsub("%%c", self:ToString())
		:gsub("%%C", ((d.year - (d.year % 1000)) / 100) + 1)
		:gsub("%%d", ("%.2i"):format(d.day))
		:gsub("%%D", ("%.2i/%.2i/%s"):format(d.month, d.day, tostring(d.year):sub(-2)))
		:gsub("%%F", ("%i-%.2i-%.2i"):format(d.year, d.month, d.day))
		:gsub("%%H", ("%.2i"):format(d.hour))
		:gsub("%%k", ("%.2i"):format(d.hour))
		:gsub("%%I", ("%.2i"):format(h12))
		:gsub("%%l", ("%.2i"):format(h12))
		:gsub("%%j", ("%.3i"):format(d.yday))
		:gsub("%%m", ("%.2i"):format(d.month))
		:gsub("%%M", ("%.2i"):format(d.min))
		:gsub("%%n", "\n")
		:gsub("%%p", (d.hour >= 12 and "PM" or "AM"))
		:gsub("%%P", (d.hour >= 12 and "pm" or "am"))
		:gsub("%%r", ("%.2i:%.2i:%.2i %s"):format(h12, d.min, d.sec, (d.hour >= 12 and "PM" or "AM")))
		:gsub("%%R", ("%.2i:%.2i"):format(d.hour, d.min))
		:gsub("%%s", math.floor(self._s))
		:gsub("%%S", ("%.2i"):format(d.sec))
		:gsub("%%t", "\t")
		:gsub("%%T", ("%.2i:%.2i:%.2i"):format(d.hour, d.min, d.sec))
		:gsub("%%w", ("%.2i"):format(d.wday))
		:gsub("%%y", tostring(d.year):sub(-2))
		:gsub("%%Y", tostring(d.year))
	return str

end


Date.New = Date.new
Date.FromJSON = Date.fromJSON
Date.__tostring = Date.ToString
Date.__metatable = "locked"


function Date.__lt(d1, d2)
	return (d1._s < d2._s)
end


function Date.__le(d1, d2)
	return (d1._s <= d2._s)
end


function Date.__eq(d1, d2)
	return (d1._s == d2._s)
end


function Date.__unm(d)
	return Date.new(-d._s)
end


return Date]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAAE0D697CE334A80A9A31E36FFB69F2F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Event</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Event
-- Stephen Leitnick
-- March 17, 2017

--[[
	
	event = Event.new()
	
	event:Fire(...)
	event:Wait()
	event:Connect(functionHandler)
	event:DisconnectAll()
	event:Destroy()
	
	
	Using 'Connect':

		connection = event:Connect(func)
			connection.Connected
			connection:Disconnect()
	

	-----------------------------------------------------------------------------

	NOTE ON MEMORY LEAK PREVENTION:
		If an event is no longer being used, be sure to invoke the 'Destroy' method
		to ensure that all events are properly released. Failure to do so could
		result in memory leaks due to connections still being referenced.

	WHY NOT BINDABLE EVENTS:
		This module passes by reference, whereas BindableEvents pass by value.
		In other words, BindableEvents will create a copy of whatever is passed
		rather than the original value itself. This becomes difficult when dealing
		with tables, where passing by reference is usually most ideal.
	
--]]



local ASSERT  = assert
local SELECT  = select
local UNPACK  = unpack
local TYPE    = type


local Event = {}
Event.__index = Event


function Event.new()
	
	local self = setmetatable({
		_connections = {};
		_destroyed = false;
		_firing = false;
		_bindable = Instance.new("BindableEvent");
	}, Event)
	
	return self
	
end


function Event:Fire(...)
	self._args = {...}
	self._numArgs = SELECT("#", ...)
	self._bindable:Fire()
end


function Event:Wait()
	self._bindable.Event:Wait()
	return UNPACK(self._args, 1, self._numArgs)
end


function Event:Connect(func)
	ASSERT(not self._destroyed, "Cannot connect to destroyed event")
	ASSERT(TYPE(func) == "function", "Argument must be function")
	return self._bindable.Event:Connect(function()
		func(UNPACK(self._args, 1, self._numArgs))
	end)
end


function Event:DisconnectAll()
	self._bindable:Destroy()
	self._bindable = Instance.new("BindableEvent")
end


function Event:Destroy()
	if (self._destroyed) then return end
	self._destroyed = true
	self._bindable:Destroy()
end


return Event]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF22D163255D740C6BB6CAA5AB25E52D8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ListenerList</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Listener List
-- Stephen Leitnick
-- November 1, 2015

--[[
	
	local listeners = ListenerList.new()
	
	listeners:Connect(event, func)
	listeners:BindToRenderStep(name, priority, func)
	listeners:BindAction(actionName, funcToBind, createTouchBtn [, inputTypes...])
	listeners:BindActionAtPriority(actionName, funcToBind, createTouchBtn, priorityLevel [, inputTypes...])

	listeners:DisconnectAll()
	listeners:DisconnectEvents()
	listeners:DisconnectRenderSteps()
	listeners:DisconnectActions()

	listeners:Destroy()
		> Alias for DisconnectAll
	
--]]



local ListenerList = {}
ListenerList.__index = ListenerList


function ListenerList.new()
	local self = setmetatable({
		_listeners = {};
		_renderStepNames = {};
		_actionNames = {};
	}, ListenerList)
	return self
end


-- Connect a function to an event and store it in the list:
function ListenerList:Connect(event, func)
	local listener = event:Connect(func)
	table.insert(self._listeners, listener)
	return listener
end


function ListenerList:BindToRenderStep(name, ...)
	table.insert(self._renderStepNames, name)
	game:GetService("RunService"):BindToRenderStep(name, ...)
end


function ListenerList:BindAction(name, ...)
	table.insert(self._actionNames, name)
	game:GetService("ContextActionService"):BindAction(name, ...)
end


function ListenerList:BindActionAtPriority(name, ...)
	table.insert(self._actionNames, name)
	game:GetService("ContextActionService"):BindActionAtPriority(name, ...)
end


function ListenerList:DisconnectEvents()
	for _,l in ipairs(self._listeners) do
		if (l.Connected) then
			l:Disconnect()
		end
	end
	self._listeners = {}
end


function ListenerList:DisconnectRenderSteps()
	local runService = game:GetService("RunService")
	for _,n in ipairs(self._renderStepNames) do
		runService:UnbindFromRenderStep(n)
	end
	self._renderStepNames = {}
end


function ListenerList:DisconnectActions()
	local ctxService = game:GetService("ContextActionService")
	for _,n in ipairs(self._actionNames) do
		ctxService:UnbindAction(n)
	end
	self._actionNames = {}
end


-- Disconnect all events in the list and clear the list:
function ListenerList:DisconnectAll()
	self:DisconnectEvents()
	self:DisconnectRenderSteps()
	self:DisconnectActions()
end


ListenerList.Destroy = ListenerList.DisconnectAll


return ListenerList]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX10EB76F93E654C26879D024FA10E73CB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Maid</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Maid
-- Author: Quenty
-- Source: https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Events/Maid.lua
-- License: MIT (https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md)
-- This module has been modified for use in AeroGameFramework

--[[

	maid = Maid.new()

	maid:GiveTask(task)
		> task is an event connection, function, or instance/table with a 'Destroy' method

	maid:GivePromise(promise)
	
	maid:DoCleaning()
		> Alias for Destroy
	
	maid:Destroy()
		> Goes through each task & disconnects events, destroys instances, and calls functions

--]]

---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

local Promise


--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	local self = setmetatable({
		_tasks = {};
	}, Maid)
	return self
end


--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if (Maid[index]) then
		return Maid[index]
	else
		return self._tasks[index]
	end
end


--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if (Maid[index] ~= nil) then
		error(("'%s' is reserved"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]
	tasks[index] = newTask

	if (oldTask) then
		if (type(oldTask) == "function") then
			oldTask()
		elseif (typeof(oldTask) == "RBXScriptConnection") then
			oldTask:Disconnect()
		elseif (oldTask.Destroy) then
			oldTask:Destroy()
		end
	end
end


--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = (#self._tasks + 1)
	self[taskId] = task

	if (type(task) == "table" and (not task.Destroy)) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end


function Maid:GivePromise(promise)
	if (promise:GetStatus() ~= Promise.Status.Started) then
		return promise
	end

	local newPromise = Promise.Resolve(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end


--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, task in pairs(tasks) do
		if (typeof(task) == "RBXScriptConnection") then
			tasks[index] = nil
			task:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, task = next(tasks)
	while (task ~= nil) do
		tasks[index] = nil
		if (type(task) == "function") then
			task()
		elseif (typeof(task) == "RBXScriptConnection") then
			task:Disconnect()
		elseif (task.Destroy) then
			task:Destroy()
		end
		index, task = next(tasks)
	end
end


function Maid:Init()
	Promise = self.Shared.Promise
end


--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC7884147550E4E0E8C93AA371A00F8CC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NumberUtil</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Number Util
-- Stephen Leitnick
-- April 22, 2020

--[[

	NumberUtil.E
	NumberUtil.Tau

	NumberUtil.Lerp(min, max, alpha)
	NumberUtil.LerpClamp(min, max, alpha)
	NumberUtil.InverseLerp(min, max, num)
	NumberUtil.Map(num, inMin, inMax, outMin, outMax)
	NumberUtil.Round(num)
	NumberUtil.RoundTo(num, multiple)


	EXAMPLES:

		Lerp:

			Interpolate between two numbers by a certain alpha/percentage.

			Visually, think of a number line ranging from 'min' to 'max'
			and then move along that line by 'alpha' percent.

			Lerp(5, 15, 0.5) == 10
			Lerp(5, 15, 0)   == 5
			Lerp(5, 15, 0.7) == 12
			Lerp(5, 15, 2)   == 25  (unusual to have alpha outside of 0-1. See LerpClamp.)


		LerpClamp:

			The same as Lerp, but the 'alpha' value is clamped between 0-1,
			which will guarantee that the output is within bounds of the
			min and max values.

			LerpClamp(5, 15, 0.5) == 10
			LerpClamp(5, 15, 2)   == 15  (alpha of 2 was clamped down to 1)


		InverseLerp:

			The inverse of the Lerp function. It returns the alpha value
			between the range of [min, max] given the number.

			InverseLerp(5, 15, 10) == 0.5
			InverseLerp(5, 15, 12) == 0.7

		Map:

			Remaps the range of 'num' from its old range of [inMin, inMax]
			to a new range of [outMin, outMax]. This is useful when needing
			to convert a range of inputs to a different output. For instance,
			remapping gamepad stick input to a larger range controlling a
			vehicle steering wheel.

			Map(0.5, 0, 1, -10, 10) == 0
			Map(1, -1, 1, 0, 5)     == 5


		Round:

			Rounds a number to the nearest whole number.

			Round(1.5)  == 2
			Round(3.2)  == 3
			Round(-0.5) == -1


		RoundTo:

			Rounds a number to the nearest given multiple. An example would be
			locking world positions onto a larger grid.

			RoundTo(3.4, 5) == 5
			RoundTo(12, 5)  == 10

--]]


local NumberUtil = {}


NumberUtil.E = 2.7182818284590
NumberUtil.Tau = math.pi * 2


function NumberUtil.Lerp(min, max, alpha)
	return (min + ((max - min) * alpha))
end


function NumberUtil.LerpClamp(min, max, alpha)
	return NumberUtil.Lerp(min, max, math.clamp(alpha, 0, 1))
end


function NumberUtil.InverseLerp(min, max, num)
	return ((num - min) / (max - min))
end


function NumberUtil.Map(n, inMin, inMax, outMin, outMax)
	return (outMin + ((outMax - outMin) * ((n - inMin) / (inMax - inMin))))
end


function NumberUtil.Round(num)
	return (num >= 0 and math.floor(num + 0.5) or math.ceil(num - 0.5))
end


function NumberUtil.RoundTo(num, multiple)
	return NumberUtil.Round(num / multiple) * multiple
end


return NumberUtil]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCAF93E794D3B4847903C21839EA962AA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Promise</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[

	MIT License

	Copyright (c) 2019 Eryn L. K.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

--]]

--[[

	Repository: https://github.com/evaera/roblox-lua-promise
	- An implementation of Promises similar to Promise/A+
	- Author: evaera
	- Modifications by Crazyman32 (December 29, 2019)

	Static Methods:
		Promise.new(callback)
		Promise.Async(callback)
		Promise.Resolve(...)
		Promise.Reject(...)
		Promise.Try(...)
		Promise.All(promises)
		Promise.Some(promises, amount)
		Promise.Any(promises)
		Promise.AllSettled(promises)
		Proimse.Race(promises)
		Promise.Is(object)
		Promise.Promisify(callback)
		Promise.Delay(seconds)

	Object Methods:
		promise:Timeout(seconds, timeoutValue)
		promise:GetStatus()
		promise:Then(successHandler, failureHandler)
		promise:Catch(failureCallback)
		promise:Tap(tapCallback)
		promise:ThenCall(callback, ...)
		promise:ThenReturn(...)
		promise:Cancel()
		promise:Destroy()
		promise:Finally(finallyHandler)
		promise:FinallyCall(callback, ...)
		promise:FinallyReturn(...)
		promise:Done(finallyHandler)
		promise:DoneCall(callback, ...)
		promise:DoneReturn(...)
		promise:AwaitStatus()
		promise:Await()
		promise:Expect(...)
		promise:AwaitValue(...)

--]]

local ERROR_YIELD_NEW = "Yielding inside Promise.new is not allowed! Use Promise.async or create a new thread in the Promise executor!"
local ERROR_YIELD_THEN = "Yielding inside andThen/catch is not allowed! Instead, return a new Promise from andThen/catch."
local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"

local RunService = game:GetService("RunService")

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	local len = select("#", ...)
	return len, { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(...)
	local result = (...)
	return result, pack(select(2, ...))
end

--[[
	Calls a non-yielding function in a new coroutine.

	Handles errors if they happen.
]]
local function ppcall(yieldError, callback, ...)
	-- Wrapped because C functions can't be passed to coroutine.create!
	local co = coroutine.create(function(...)
		return callback(...)
	end)

	local ok, len, result = packResult(coroutine.resume(co, ...))

	if ok and coroutine.status(co) ~= "dead" then
		error(yieldError, 2)
	end

	return ok, len, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = ppcall(ERROR_YIELD_THEN, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1] .. "\n" .. traceback)
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = setmetatable({
	Started = "Started",
	Resolved = "Resolved",
	Rejected = "Rejected",
	Cancelled = "Cancelled",
}, {
	__index = function(_, k)
		error(("%s is not in Promise.Status!"):format(k), 2)
	end
})

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise.new(callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		_status = Promise.Status.Started,

		-- Will be set to the Lua error string if it occurs while executing.
		_error = nil,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation.
		_parent = parent,

		_consumers = setmetatable({}, {
			__mode = "k";
		}),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	local ok, _, result = ppcall(
		ERROR_YIELD_NEW,
		callback,
		resolve,
		reject,
		onCancel
	)

	if not ok then
		self._error = result[1] or "error"
		reject((result[1] or "error") .. "\n" .. self._source)
	end

	return self
end

function Promise._newWithSelf(executor, ...)
	local args
	local promise = Promise.new(function(...)
		args = {...}
	end, ...)

	executor(promise, unpack(args))

	return promise
end

function Promise._new(traceback, executor, ...)
	return Promise._newWithSelf(function(self, ...)
		self._source = traceback

		executor(...)
	end, ...)
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.async(callback)
	local traceback = debug.traceback()
	local promise
	promise = Promise.new(function(resolve, reject, onCancel)
		local connection
		connection = RunService.Heartbeat:Connect(function()
			connection:Disconnect()
			local ok, err = pcall(callback, resolve, reject, onCancel)

			if not ok then
				promise._error = err or "error"
				reject(err .. "\n" .. traceback)
			end
		end)
	end)

	return promise
end
Promise.Async = Promise.async

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise.new(function(resolve)
		resolve(unpack(values, 1, length))
	end)
end
Promise.Resolve = Promise.resolve

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise.new(function(_, reject)
		reject(unpack(values, 1, length))
	end)
end
Promise.Reject = Promise.reject

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise.resolve():andThenCall(...)
end
Promise.Try = Promise.try

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(ERROR_NON_LIST:format("Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error((ERROR_NON_PROMISE_IN_LIST):format("Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._newWithSelf(function(self, resolve, reject, onCancel)
		self._source = traceback

		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			table.insert(
				newPromises,
				promises[i]:andThen(
					function(...)
						resolveOne(i, ...)
					end,
					function(...)
						rejectedCount = rejectedCount + 1

						if amount == nil or #promises - rejectedCount < amount then
							cancel()
							done = true

							reject(...)
						end
					end
				)
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(), promises)
end
Promise.All = Promise.all

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(), promises, amount)
end
Promise.Some = Promise.some

function Promise.any(promises)
	return Promise._all(debug.traceback(), promises, 1):andThen(function(values)
		return values[1]
	end)
end
Promise.Any = Promise.any

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(ERROR_NON_LIST:format("Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error((ERROR_NON_PROMISE_IN_LIST):format("Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise.new(function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			table.insert(
				newPromises,
				promises[i]:finally(
					function(...)
						resolveOne(i, ...)
					end
				)
			)
		end
	end)
end
Promise.AllSettled = Promise.allSettled

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", ERROR_NON_LIST:format("Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), (ERROR_NON_PROMISE_IN_LIST):format("Promise.race", tostring(i)))
	end

	return Promise.new(function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for _, promise in ipairs(promises) do
			table.insert(
				newPromises,
				promise:andThen(finalize(resolve), finalize(reject))
			)
		end

		if finished then
			cancel()
		end
	end)
end
Promise.Race = Promise.race

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return type(object.andThen) == "function"
end
Promise.Is = Promise.is

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		local traceback = debug.traceback()
		local length, values = pack(...)
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, resultLength, resultValues = packResult(pcall(callback, unpack(values, 1, length)))
				if ok then
					resolve(unpack(resultValues, 1, resultLength))
				else
					reject((resultValues[1] or "error") .. "\n" .. traceback)
				end
			end)()
		end)
	end
end
Promise.Promisify = Promise.promisify

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	local connection
	local queue = {}

	local function enqueue(callback, seconds)
		table.insert(queue, {
			callback = callback,
			startTime = tick(),
			endTime = tick() + math.max(seconds, 1/60)
		})

		table.sort(queue, function(a, b)
			return a.endTime < b.endTime
		end)

		if not connection then
			connection = RunService.Heartbeat:Connect(function()
				while #queue > 0 and queue[1].endTime <= tick() do
					local item = table.remove(queue, 1)

					item.callback(tick() - item.startTime)
				end

				if #queue == 0 then
					connection:Disconnect()
					connection = nil
				end
			end)
		end
	end

	local function dequeue(callback)
		for i, item in ipairs(queue) do
			if item.callback == callback then
				table.remove(queue, i)
				break
			end
		end
	end

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, or NaN, assume seconds is 0.
		-- This mirrors the behavior of wait()
		if seconds < 0 or seconds == math.huge or seconds ~= seconds then
			seconds = 0
		end

		return Promise.new(function(resolve, _, onCancel)
			enqueue(resolve, seconds)

			onCancel(function()
				dequeue(resolve)
			end)
		end)
	end
	Promise.Delay = Promise.delay
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, timeoutValue)
	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(timeoutValue == nil and "Timed out" or timeoutValue)
		end),
		self
	})
end
Promise.prototype.Timeout = Promise.prototype.timeout

function Promise.prototype:getStatus()
	return self._status
end
Promise.prototype.GetStatus = Promise.prototype.getStatus

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject("Promise is cancelled")
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:andThen")
	)

	return self:_andThen(debug.traceback(), successHandler, failureHandler)
end
Promise.prototype.AndThen = Promise.prototype.andThen
Promise.prototype.Then = Promise.prototype.andThen

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		ERROR_NON_FUNCTION:format("Promise:catch")
	)
	return self:_andThen(debug.traceback(), nil, failureCallback)
end
Promise.prototype.Catch = Promise.prototype.catch

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", ERROR_NON_FUNCTION:format("Promise:tap"))
	return self:_andThen(debug.traceback(), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end
Promise.prototype.Tap = Promise.prototype.tap

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", ERROR_NON_FUNCTION:format("Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(), function()
		return callback(unpack(values, 1, length))
	end)
end
Promise.prototype.AndThenCall = Promise.prototype.andThenCall
Promise.prototype.ThenCall = Promise.prototype.andThenCall

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(), function()
		return unpack(values, 1, length)
	end)
end
Promise.prototype.AndThenReturn = Promise.prototype.andThenReturn
Promise.prototype.ThenReturn = Promise.prototype.andThenReturn

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end
Promise.prototype.Cancel = Promise.prototype.cancel
Promise.prototype.Destroy = Promise.prototype.cancel

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:finally")
	)
	return self:_finally(debug.traceback(), finallyHandler)
end
Promise.prototype.Finally = Promise.prototype.finally

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", ERROR_NON_FUNCTION:format("Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return callback(unpack(values, 1, length))
	end)
end
Promise.prototype.FinallyCall = Promise.prototype.finallyCall

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return unpack(values, 1, length)
	end)
end
Promise.prototype.FinallyReturn = Promise.prototype.finallyReturn

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		ERROR_NON_FUNCTION:format("Promise:finallyO")
	)
	return self:_finally(debug.traceback(), finallyHandler, true)
end
Promise.prototype.Done = Promise.prototype.done

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", ERROR_NON_FUNCTION:format("Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return callback(unpack(values, 1, length))
	end, true)
end
Promise.prototype.DoneCall = Promise.prototype.doneCall

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(), function()
		return unpack(values, 1, length)
	end, true)
end
Promise.prototype.DoneReturn = Promise.prototype.doneReturn

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end
Promise.prototype.AwaitStatus = Promise.prototype.awaitStatus

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await(...)
	local length, result = pack(self:awaitStatus(...))
	local status = table.remove(result, 1)

	return status == Promise.Status.Resolved, unpack(result, 1, length - 1)
end
Promise.prototype.Await = Promise.prototype.await

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect(...)
	local length, result = pack(self:awaitStatus(...))
	local status = table.remove(result, 1)

	assert(
		status == Promise.Status.Resolved,
		tostring(result[1] == nil and "" or result[1])
	)

	return unpack(result, 1, length - 1)
end
Promise.prototype.Expect = Promise.prototype.expect

Promise.prototype.awaitValue = Promise.prototype.expect
Promise.prototype.AwaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				-- The handler errored. Replace the inner stack trace with our outer stack trace.
				if chainedPromise._error then
					return self:_reject((chainedPromise._error or "") .. "\n" .. self._source)
				end
				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			RunService.Heartbeat:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message
			if self._error then
				message = ("Unhandled promise rejection:\n\n%s"):format(err)
			else
				message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
					err,
					self._source
				)
			end
			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		callback(self._status)
	end

	if self._parent and self._error == nil then
		self._error = self._parent._error
	end

	-- Allow family to be buried
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

return Promise]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB73C996F6F5E40CDBDFC0838579738AB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StringUtil</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- String Util
-- Stephen Leitnick
-- December 3, 2019

--[[

	StringUtil.Trim(String str)
	StringUtil.TrimStart(String str)
	StringUtil.TrimEnd(String str)
	StringUtil.EqualsIgnoreCase(String str, String compare)
	StringUtil.RemoveWhitespace(String str)
	StringUtil.RemoveExcessWhitespace(String str)
	StringUtil.EndsWith(String str, String endsWith)
	StringUtil.StartsWith(String str, String startsWith)
	StringUtil.Contains(String str, String contains)
	StringUtil.ToCharArray(String str)
	StringUtil.ToByteArray(String str)
	StringUtil.ByteArrayToString(Table bytes)
	StringUtil.ToCamelCase(String str)
	StringUtil.ToPascalCase(String str)
	StringUtil.ToSnakeCase(String str [, uppercase])
	StringUtil.ToKebabCase(String str [, uppercase])
	StringUtil.Escape(str)
	StringUtil.StringBuilder()

	EXAMPLES:

		Trim:

			Trims whitespace from the start and end of the string.

			StringUtil.Trim("  hello world  ") == "hello world"


		TrimStart:

			The same as Trim, but only trims the start of the string.

			StringUtil.TrimStart("  hello world  ") == "hello world  "


		TrimEnd:

			The same as Trim, but only trims the end of the string.

			StringUtil.TrimEnd("  hello world  ") == "  hello world"


		EqualsIgnoreCase:

			Checks if two strings are equal, but ignores their case.

			StringUtil.EqualsIgnoreCase("HELLo woRLD", "hEllo wORLd") == true


		RemoveWhitespace:

			Removes all whitespace from a string.

			StringUtil.RemoveWhitespace("  hello World!\n") == "helloWorld!"


		RemoveExcessWhitespace:

			Replaces all whitespace with a single space. This does not trim the string.

			StringUtil.RemoveExcessWhitespace("This     is    a   \n  test") == "This is a test"


		EndsWith:

			Checks if a string ends with a certain string.

			StringUtil.EndsWith("Hello world", "rld") == true


		StartsWith:

			Checks if a string starts with a certain string.

			StringUtil.StartsWith("Hello world", "He") == true


		Contains:

			Checks if a string contains another string.

			StringUtil.Contains("Hello world", "lo wor") == true


		ToCharArray:

			Returns a table of all the characters in the string.

			StringUtil.ToCharArray("Hello") >>> {"H","e","l","l","o"}


		ToByteArray:

			Returns a table of all the bytes of each character in the string.

			StringUtil.ToByteArray("Hello") >>> {72,101,108,108,111}


		ByteArrayToString:

			Transforms an array of bytes into a string.

			StringUtil.ByteArrayToString({97, 98, 99}) == "abc"


		ToCamelCase:
		
			Returns a string in camelCase.

			StringUtil.ToCamelCase("Hello_world-abc") == "helloWorldAbc"


		ToPascalCase:
		
			Returns a string in PascalCase.

			StringUtil.ToPascalCase("Hello_world-abc") == "HelloWorldAbc"


		ToSnakeCase:
		
			Returns a string in snake_case or SNAKE_CASE.

			StringUtil.ToPascalCase("Hello_world-abc") == "hello_world_abc"
			StringUtil.ToPascalCase("Hello_world-abc", true) == "HELLO_WORLD_ABC"


		ToKebabCase:
		
			Returns a string in kebab-case or KEBAB-CASE.

			StringUtil.ToKebabCase("Hello_world-abc") == "hello-world-abc"
			StringUtil.ToKebabCase("Hello_world-abc", true) == "HELLO-WORLD-ABC"


		Escape:

			Escapes a string from pattern characters. In other words, it prefixes
			any special pattern characters with a %. For example, the dollar
			sign $ would become %$. See the example below.

			StringUtil.Escape("Hello. World$ ^-^") == "Hello%. World%$ %^%-%^"


		StringBuilder:

			Creates a StringBuilder object that can be used to build a string. This
			is useful when a large string needs to be concatenated. Traditional
			concatenation of a string using ".." can be a performance issue, and thus
			StringBuilders can be used to store the pieces of the string in a table
			and then concatenate them all at once.

			local builder = StringUtil.StringBuilder()

			builder:Append("world")
			builder:Prepend("Hello ")
			builder:ToString() == "Hello world"
			tostring(builder)  == "Hello world"

--]]


local StringUtil = {}

local MAX_TUPLE = 7997


function StringUtil.Escape(str)
	local escaped = str:gsub("([%.%$%^%(%)%[%]%+%-%*%?%%])", "%%%1")
	return escaped
end


function StringUtil.Trim(str)
	return str:match("^%s*(.-)%s*$")
end


function StringUtil.TrimStart(str)
	return str:match("^%s*(.+)")
end


function StringUtil.TrimEnd(str)
	return str:match("(.-)%s*$")
end


function StringUtil.RemoveExcessWhitespace(str)
	return str:gsub("%s+", " ")
end


function StringUtil.RemoveWhitespace(str)
	return str:gsub("%s+", "")
end


function StringUtil.EndsWith(str, ends)
	return str:match(StringUtil.Escape(ends) .. "$") ~= nil
end


function StringUtil.StartsWith(str, starts)
	return str:match("^" .. StringUtil.Escape(starts)) ~= nil
end


function StringUtil.Contains(str, contains)
	return str:find(contains) ~= nil
end


function StringUtil.StringBuilder()
	local sb = {}
	local str = {}
	function sb:Append(s)
		str[#str + 1] = s
	end
	function sb:Prepend(s)
		table.insert(str, 1, s)
	end
	function sb:ToString()
		return table.concat(str, "")
	end
	setmetatable(sb, {__tostring=sb.ToString})
	return sb
end


function StringUtil.ToCharArray(str)
	local len = #str
	local chars = table.create(len)
	for i = 1,len do
		chars[i] = str:sub(i, i)
	end
	return chars
end


function StringUtil.ToByteArray(str)
	local len = #str
	if (len == 0) then return {} end
	if (len <= MAX_TUPLE) then
		return table.pack(str:byte(1, #str))
	end
	local bytes = table.create(len)
	for i = 1,len do
		bytes[i] = str:sub(i, i):byte()
	end
	return bytes
end


function StringUtil.ByteArrayToString(bytes)
	local size = #bytes
	if (size <= MAX_TUPLE) then
		return string.char(table.unpack(bytes))
	end
	local numChunks = math.ceil(size / MAX_TUPLE)
	local stringBuild = table.create(numChunks)
	for i = 1, numChunks do
		local chunk = string.char(table.unpack(bytes, ((i - 1) * MAX_TUPLE) + 1, math.min(size, ((i - 1) * MAX_TUPLE) + MAX_TUPLE)))
		stringBuild[i] = chunk
	end
	return table.concat(stringBuild, "")
end


function StringUtil.EqualsIgnoreCase(str1, str2)
	return (str1:lower() == str2:lower())
end


function StringUtil.ToCamelCase(str)
	str = str:gsub("[%-_]+([^%-_])", function(s) return s:upper() end)
	return str:sub(1, 1):lower() .. str:sub(2)
end


function StringUtil.ToPascalCase(str)
	str = StringUtil.ToCamelCase(str)
	return str:sub(1, 1):upper() .. str:sub(2)
end


function StringUtil.ToSnakeCase(str, uppercase)
	str = str:gsub("[%-_]+", "_"):gsub("([^%u%-_])(%u)", function(s1, s2) return s1 .. "_" .. s2:lower() end)
	if (uppercase) then str = str:upper() else str = str:lower() end
	return str
end


function StringUtil.ToKebabCase(str, uppercase)
	str = str:gsub("[%-_]+", "-"):gsub("([^%u%-_])(%u)", function(s1, s2) return s1 .. "-" .. s2:lower() end)
	if (uppercase) then str = str:upper() else str = str:lower() end
	return str
end


setmetatable(StringUtil, {__index = string})


return StringUtil]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBC4074127B7049EB85C8604B26FB3606">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TableUtil</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Table Util
-- Stephen Leitnick
-- September 13, 2017

--[[
	
	TableUtil.Copy(Table tbl)
	TableUtil.CopyShallow(Table tbl)
	TableUtil.Sync(Table tbl, Table templateTbl)
	TableUtil.Print(Table tbl, String label, Boolean deepPrint)
	TableUtil.FastRemove(Table tbl, Number index)
	TableUtil.FastRemoveFirstValue(Table tbl, Variant value)
	TableUtil.Map(Table tbl, Function callback)
	TableUtil.Filter(Table tbl, Function callback)
	TableUtil.Reduce(Table tbl, Function callback [, Number initialValue])
	TableUtil.Assign(Table target, ...Table sources)
	TableUtil.IndexOf(Table tbl, Variant item)
	TableUtil.Reverse(Table tbl)
	TableUtil.Shuffle(Table tbl)
	TableUtil.IsEmpty(Table tbl)
	TableUtil.EncodeJSON(Table tbl)
	TableUtil.DecodeJSON(String json)

	EXAMPLES:

		Copy:

			Performs a deep copy of the given table. In other words,
			all nested tables will also get copied.

			local tbl = {"a", "b", "c"}
			local tblCopy = TableUtil.Copy(tbl)


		CopyShallow:

			Performs a shallow copy of the given table. In other words,
			all nested tables will not be copied, but only moved by
			reference. Thus, a nested table in both the original and
			the copy will be the same.

			local tbl = {"a", "b", "c"}
			local tblCopy = TableUtil.CopyShallow(tbl)


		Sync:

			Synchronizes a table to a template table. If the table does not have an
			item that exists within the template, it gets added. If the table has
			something that the template does not have, it gets removed.

			local tbl1 = {kills = 0; deaths = 0; points = 0}
			local tbl2 = {points = 0}
			TableUtil.Sync(tbl2, tbl1)  -- In words: "Synchronize table2 to table1"
			print(tbl2.deaths)


		Print:

			Prints out the table to the output in an easy-to-read format. Good for
			debugging tables. If deep printing, avoid cyclical references.

			local tbl = {a = 32; b = 64; c = 128; d = {x = 0; y = 1; z = 2}}
			TableUtil.Print(tbl, "My Table", true)


		FastRemove:

			Removes an item from an array at a given index. Only use this if you do
			NOT care about the order of your array. This works by simply popping the
			last item in the array and overwriting the given index with the last
			item. This is O(1), compared to table.remove's O(n) speed.

			local tbl = {"hello", "there", "this", "is", "a", "test"}
			TableUtil.FastRemove(tbl, 2)   -- Remove "there" in the array
			print(table.concat(tbl, " "))  -- > hello test is a


		FastRemoveFirstValue:

			Calls FastRemove on the first index that holds the given value.

			local tbl = {"abc", "hello", "hi", "goodbye", "hello", "hey"}
			local removed, atIndex = TableUtil.FastRemoveFirstValue(tbl, "hello")
			if (removed) then
				print("Removed at index " .. atIndex)
				print(table.concat(tbl, " "))  -- > abc hi goodbye hello hey
			else
				print("Did not find value")
			end

		
		Map:

			This allows you to construct a new table by calling the given function
			on each item in the table.

			local peopleData = {
				{firstName = "Bob"; lastName = "Smith"};
				{firstName = "John"; lastName = "Doe"};
				{firstName = "Jane"; lastName = "Doe"};
			}

			local people = TableUtil.Map(peopleData, function(item)
				return {Name = item.firstName .. " " .. item.lastName}
			end)

			-- 'people' is now an array that looks like: { {Name = "Bob Smith"}; ... }


		Filter:

			This allows you to create a table based on the given table and a filter
			function. If the function returns 'true', the item remains in the new
			table; if the function returns 'false', the item is discluded from the
			new table.

			local people = {
				{Name = "Bob Smith"; Age = 42};
				{Name = "John Doe"; Age = 34};
				{Name = "Jane Doe"; Age = 37};
			}

			local peopleUnderForty = TableUtil.Filter(people, function(item)
				return item.Age < 40
			end)


		Reduce:

			This allows you to reduce an array to a single value. Useful for quickly
			summing up an array.

			local tbl = {40, 32, 9, 5, 44}
			local tblSum = TableUtil.Reduce(tbl, function(accumulator, value)
				return accumulator + value
			end)
			print(tblSum)  -- > 130


		Assign:

			This allows you to assign values from multiple tables into one. The
			Assign function is very similar to JavaScript's Object.Assign() and
			is useful for things such as composition-designed systems.

			local function Driver()
				return {
					Drive = function(self) self.Speed = 10 end;
				}
			end

			local function Teleporter()
				return {
					Teleport = function(self, pos) self.Position = pos end;
				}
			end

			local function CreateCar()
				local state = {
					Speed = 0;
					Position = Vector3.new();
				}
				-- Assign the Driver and Teleporter components to the car:
				return TableUtil.Assign({}, Driver(), Teleporter())
			end

			local car = CreateCar()
			car:Drive()
			car:Teleport(Vector3.new(0, 10, 0))


		IndexOf:

			Returns the index of the given item in the table. If not found, this
			will return nil.

			This is the same as table.find, which Roblox added after this method
			was written. To keep backwards compatibility, this method will continue
			to exist, but will point directly to table.find.

			local tbl = {"Hello", 32, true, "abc"}
			local abcIndex = TableUtil.IndexOf(tbl, "abc")     -- > 4
			local helloIndex = TableUtil.IndexOf(tbl, "Hello") -- > 1
			local numberIndex = TableUtil.IndexOf(tbl, 64)     -- > nil


		Reverse:

			Creates a reversed version of the array. Note: This is a shallow
			copy, so existing references will remain within the new table.

			local tbl = {2, 4, 6, 8}
			local rblReversed = TableUtil.Reverse(tbl)  -- > {8, 6, 4, 2}


		Shuffle:

			Shuffles (i.e. randomizes) an array. This uses the Fisher-Yates algorithm.

			local tbl = {1, 2, 3, 4, 5, 6, 7, 8, 9}
			TableUtil.Shuffle(tbl)
			print(table.concat(tbl, ", "))  -- e.g. > 3, 6, 9, 2, 8, 4, 1, 7, 5
	
--]]



local TableUtil = {}

local http = game:GetService("HttpService")

local IndexOf = table.find


local function CopyTable(t)
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = CopyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end


local function CopyTableShallow(t)
	local tCopy = table.create(#t)
	for k,v in pairs(t) do tCopy[k] = v end
	return tCopy
end


local function Sync(tbl, templateTbl)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(type(templateTbl) == "table", "Second argument must be a table")
	
	-- If 'tbl' has something 'templateTbl' doesn't, then remove it from 'tbl'
	-- If 'tbl' has something of a different type than 'templateTbl', copy from 'templateTbl'
	-- If 'templateTbl' has something 'tbl' doesn't, then add it to 'tbl'
	for k,v in pairs(tbl) do
		
		local vTemplate = templateTbl[k]
		
		-- Remove keys not within template:
		if (vTemplate == nil) then
			tbl[k] = nil
			
		-- Synchronize data types:
		elseif (type(v) ~= type(vTemplate)) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end
		
		-- Synchronize sub-tables:
		elseif (type(v) == "table") then
			Sync(v, vTemplate)
		end
		
	end
	
	-- Add any missing keys:
	for k,vTemplate in pairs(templateTbl) do
		
		local v = tbl[k]
		
		if (v == nil) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end
		end
		
	end
	
end


local function FastRemove(t, i)
	local n = #t
	t[i] = t[n]
	t[n] = nil
end


local function Map(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	local newT = table.create(#t)
	for k,v in pairs(t) do
		newT[k] = f(v, k, t)
	end
	return newT
end


local function Filter(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	local newT = table.create(#t)
	if (#t > 0) then
		local n = 0
		for i = 1,#t do
			local v = t[i]
			if (f(v, i, t)) then
				n = (n + 1)
				newT[n] = v
			end
		end
	else
		for k,v in pairs(t) do
			if (f(v, k, t)) then
				newT[k] = v
			end
		end
	end
	return newT
end


local function Reduce(t, f, init)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	assert(init == nil or type(init) == "number", "Third argument must be a number or nil")
	local result = (init or 0)
	for k,v in pairs(t) do
		result = f(result, v, k, t)
	end
	return result
end


-- tableUtil.Assign(Table target, ...Table sources)
local function Assign(target, ...)
	for _,src in ipairs({...}) do
		for k,v in pairs(src) do
			target[k] = v
		end
	end
	return target
end


local function Print(tbl, label, deepPrint)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(label == nil or type(label) == "string", "Second argument must be a string or nil")
	
	label = (label or "TABLE")
	
	local strTbl = {}
	local indent = " - "
	
	-- Insert(string, indentLevel)
	local function Insert(s, l)
		strTbl[#strTbl + 1] = (indent:rep(l) .. s .. "\n")
	end
	
	local function AlphaKeySort(a, b)
		return (tostring(a.k) < tostring(b.k))
	end
	
	local function PrintTable(t, lvl, lbl)
		Insert(lbl .. ":", lvl - 1)
		local nonTbls = {}
		local tbls = {}
		local keySpaces = 0
		for k,v in pairs(t) do
			if (type(v) == "table") then
				table.insert(tbls, {k = k, v = v})
			else
				table.insert(nonTbls, {k = k, v = "[" .. typeof(v) .. "] " .. tostring(v)})
			end
			local spaces = #tostring(k) + 1
			if (spaces > keySpaces) then
				keySpaces = spaces
			end
		end
		table.sort(nonTbls, AlphaKeySort)
		table.sort(tbls, AlphaKeySort)
		for _,v in ipairs(nonTbls) do
			Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. v.v, lvl)
		end
		if (deepPrint) then
			for _,v in ipairs(tbls) do
				PrintTable(v.v, lvl + 1, tostring(v.k) .. (" "):rep(keySpaces - #tostring(v.k)) .. " [Table]")
			end
		else
			for _,v in ipairs(tbls) do
				Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. "[Table]", lvl)
			end
		end
	end
	
	PrintTable(tbl, 1, label)
	
	print(table.concat(strTbl, ""))
	
end


local function Reverse(tbl)
	local n = #tbl
	local tblRev = table.create(n)
	for i = 1,n do
		tblRev[i] = tbl[n - i + 1]
	end
	return tblRev
end


local function Shuffle(tbl)
	assert(type(tbl) == "table", "First argument must be a table")
	local rng = Random.new()
	for i = #tbl, 2, -1 do
		local j = rng:NextInteger(1, i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end


local function IsEmpty(tbl)
	return (next(tbl) == nil)
end


local function EncodeJSON(tbl)
	return http:JSONEncode(tbl)
end


local function DecodeJSON(str)
	return http:JSONDecode(str)
end


local function FastRemoveFirstValue(t, v)
	local index = IndexOf(t, v)
	if (index) then
		FastRemove(t, index)
		return true, index
	end
	return false, nil
end


TableUtil.Copy = CopyTable
TableUtil.CopyShallow = CopyTableShallow
TableUtil.Sync = Sync
TableUtil.FastRemove = FastRemove
TableUtil.FastRemoveFirstValue = FastRemoveFirstValue
TableUtil.Print = Print
TableUtil.Map = Map
TableUtil.Filter = Filter
TableUtil.Reduce = Reduce
TableUtil.Assign = Assign
TableUtil.IndexOf = IndexOf
TableUtil.Reverse = Reverse
TableUtil.Shuffle = Shuffle
TableUtil.IsEmpty = IsEmpty
TableUtil.EncodeJSON = EncodeJSON
TableUtil.DecodeJSON = DecodeJSON


return TableUtil]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEA822F34406449DDA292BF1A7F8EEEBF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Thread</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Thread
-- Stephen Leitnick
-- January 5, 2020

--[[

	Thread.SpawnNow(func, ...)
	Thread.Spawn(func, ...)
	Thread.Delay(waitTime, func, ...)

	SpawnNow(Function func, Arguments...)

		>	Uses a BindableEvent to spawn a new thread
			immediately. More performance-intensive than
			using Thread.Spawn, but will guarantee a
			thread is started immediately.

		>	Use this only if the thread must be executed
			right away, otherwise use Thread.Spawn for
			the sake of performance.

	Spawn(Function func, Arguments...)

		>	Uses RunService's Heartbeat to spawn a new
			thread on the next heartbeat and then
			call the given function.

		>	Better performance than Thread.SpawnNow, but
			will have a short delay of 1 frame before
			calling the function.

	Delay(Number waitTime, Function func, Arguments...)

		>	The same as Thread.Spawn, but waits to call
			the function until the in-game time as elapsed
			by 'waitTime' amount.

		>	Returns the connection to the Heartbeat event,
			so the delay can be cancelled by disconnecting
			the returned connection.

	DelayRepeat(Number intervalTime, Function func, Arguments...)

		>	The same as Thread.Delay, except it repeats
			indefinitely.
		
		>	Returns the Heartbeat connection, thus the
			repeated delay can be stopped by disconnecting
			the returned connection.

		>	Properly bound to the time interval, thus will
			not experience drift.

	
	Examples:

		Thread.Spawn(function()
			print("Hello from Spawn")
		end)

		Thread.Delay(1, function()
			print("Hello from Delay")
		end)

		Thread.SpawnNow(function()
			print("Hello from SpawnNow")
		end)

		local delayConnection = Thread.Delay(5, function()
			print("Hello?")
		end)
		delayConnection:Disconnect()

		local repeatConnection = Thread.DelayRepeat(1, function()
			print("Hello again", tick())
		end)
		wait(5)
		repeatConnection:Disconnect()


	Why:
		
		The built-in 'spawn' and 'delay' functions have the
		potential to be throttled unknowingly. This can cause
		all sorts of problems. Developers need to be certain
		when their code is going to run. This small library
		helps give the same functionality as 'spawn' and 'delay'
		but with the expected behavior.

	Why not coroutines:
		
		Coroutines are powerful, but can be extremely difficult
		to debug due to the ways that coroutines obscure the
		stack trace.

	Credit:
	
		evaera & buildthomas: https://devforum.roblox.com/t/coroutines-v-s-spawn-which-one-should-i-use/368966
		Quenty: FastSpawn (AKA SpawnNow) method using BindableEvent

--]]



local Thread = {}

local heartbeat = game:GetService("RunService").Heartbeat


function Thread.SpawnNow(func, ...)
	--[[
		This method was originally written by Quenty and is slightly
		modified for this module. The original source can be found in
		the link below, as well as the MIT license:
			https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Utility/fastSpawn.lua
			https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md
	--]]
	local args = table.pack(...)
	local bindable = Instance.new("BindableEvent")
	bindable.Event:Connect(function() func(table.unpack(args, 1, args.n)) end)
	bindable:Fire()
	bindable:Destroy()
end


function Thread.Spawn(func, ...)
	local args = table.pack(...)
	local hb
	hb = heartbeat:Connect(function()
		hb:Disconnect()
		func(table.unpack(args, 1, args.n))
	end)
end


function Thread.Delay(waitTime, func, ...)
	local args = table.pack(...)
	local executeTime = (tick() + waitTime)
	local hb
	hb = heartbeat:Connect(function()
		if (tick() >= executeTime) then
			hb:Disconnect()
			func(table.unpack(args, 1, args.n))
		end
	end)
	return hb
end


function Thread.DelayRepeat(intervalTime, func, ...)
	local args = table.pack(...)
	local nextExecuteTime = (tick() + intervalTime)
	local hb
	hb = heartbeat:Connect(function()
		if (tick() >= nextExecuteTime) then
			nextExecuteTime = (tick() + intervalTime)
			func(table.unpack(args, 1, args.n))
		end
	end)
	return hb
end


return Thread]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX85BAB8F05466440CB9F0D7F38BB80078">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VectorUtil</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Vector Util
-- Stephen Leitnick
-- April 22, 2020

--[[

	VectorUtil.ClampMagnitude(vector, maxMagnitude)
	VectorUtil.AngleBetween(vector1, vector2)
	VectorUtil.AngleBetweenSigned(vector1, vector2, axisVector)


	EXAMPLES:

		ClampMagnitude:

			Clamps the magnitude of a vector so it is only a certain length.

			ClampMagnitude(Vector3.new(100, 0, 0), 15) == Vector3.new(15, 0, 0)
			ClampMagnitude(Vector3.new(10, 0, 0), 20)  == Vector3.new(10, 0, 0)

		
		AngleBetween:

			Finds the angle (in radians) between two vectors.

			v1 = Vector3.new(10, 0, 0)
			v2 = Vector3.new(0, 10, 0)
			AngleBetween(v1, v2) == math.rad(90)

		
		AngleBetweenSigned:

			Same as AngleBetween, but returns a signed value.

			v1 = Vector3.new(10, 0, 0)
			v2 = Vector3.new(0, 0, -10)
			axis = Vector3.new(0, 1, 0)
			AngleBetweenSigned(v1, v2, axis) == math.rad(90)

--]]


local VectorUtil = {}


function VectorUtil.ClampMagnitude(vector, maxMagnitude)
	return (vector.Magnitude > maxMagnitude and (vector.Unit * maxMagnitude) or vector)
end


function VectorUtil.AngleBetween(vector1, vector2)
	return math.acos(math.clamp(vector1.Unit:Dot(vector2.Unit), -1, 1))
end


function VectorUtil.AngleBetweenSigned(vector1, vector2, axisVector)
	local angle = VectorUtil.AngleBetween(vector1, vector2)
	return angle * math.sign(axisVector:Dot(vector1:Cross(vector2)))
end


return VectorUtil]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX2BB792063C304E9CAE09A9A77A1B996E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX90C4D46B7FCB4AA893E4A1D802D068D8">
		<Properties>
			<Color3 name="Ambient">
				<R>0.541176498</R>
				<G>0.541176498</G>
				<B>0.541176498</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">2</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.752941251</R>
				<G>0.752941251</G>
				<B>0.752941251</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.501960814</R>
				<G>0.501960814</G>
				<B>0.501960814</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.200000003</float>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">3</token>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBXDD69CB4D14E74948BD1DB732711F49B1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBXF44F16B88B244BAB8ECFC4C433E70812">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX018110AA65F64D6C9F2D5FD7CAF7EF1F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>